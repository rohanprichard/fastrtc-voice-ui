{"version":3,"file":"fastrtcvoice-widget.umd.js","sources":["../src/widget.js"],"sourcesContent":["// FastRTC Voice Widget - Language-agnostic embeddable widget\nclass FastRTCVoiceWidget extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.isWebRTCConnected = false;\n    this.isConnecting = false;\n    this.peerConnection = null;\n    this.currentStream = null;\n    this.dataChannel = null;\n    this.audioOutputElement = null;\n    this.shadowClickListenerAdded = false;\n    this.playbackStarted = false;\n    this.debugEnabled = false;\n\n    // Device state\n    this.inputDevices = [];\n    this.outputDevices = [];\n    this.selectedInputDeviceId = '';\n    this.selectedOutputDeviceId = '';\n\n    // UI state\n    this.isExpanded = false;\n    this.isMicMuted = false;\n    this.menuPosition = 'bottom-right';\n    this.isDarkMode = false;\n  }\n\n  static get observedAttributes() {\n    return ['debug', 'menu-position', 'dark-mode'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'debug') {\n      this.debugEnabled = this.hasAttribute('debug');\n    } else if (name === 'menu-position') {\n      const menuPosition = this.getAttribute('menu-position');\n      if (menuPosition && ['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right'].includes(menuPosition)) {\n        this.menuPosition = menuPosition;\n      } else {\n        this.menuPosition = 'bottom-right';\n      }\n      this.render();\n    } else if (name === 'dark-mode') {\n      this.isDarkMode = this.hasAttribute('dark-mode');\n      this.render();\n    }\n  }\n\n  debugLog(...args) {\n    if (this.debugEnabled) {\n      console.log(...args);\n    }\n  }\n\n  connectedCallback() {\n    try {\n      this.apiUrl = this.getAttribute('api-url') || '';\n      this.authToken = this.getAttribute('auth-token') || '';\n      this.showDeviceSelection = this.hasAttribute('show-device-selection');\n      this.debugEnabled = this.hasAttribute('debug');\n\n      // Get menu position attribute\n      const menuPosition = this.getAttribute('menu-position');\n      if (menuPosition && ['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right'].includes(menuPosition)) {\n        this.menuPosition = menuPosition;\n      } else {\n        this.menuPosition = 'bottom-right'; // default\n      }\n\n      // Get dark mode attribute\n      this.isDarkMode = this.hasAttribute('dark-mode');\n\n    // Check for demo attributes\n    if (this.hasAttribute('is-connected')) {\n      this.isWebRTCConnected = true;\n    }\n\n      this.render();\n      this.setupEventListeners();\n      // Device enumeration now happens only when settings button is clicked\n    } catch (error) {\n      console.error('Error in connectedCallback:', error);\n    }\n  }\n\n  disconnectedCallback() {\n    this.cleanup();\n  }\n\n  // WebRTC functionality\n  async getTurnCredentials() {\n    try {\n      const response = await fetch(`${this.apiUrl}/webrtc/turn-credentials`, {\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get TURN credentials: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching TURN credentials:', error);\n      return {\n        iceServers: [\n          { urls: 'stun:stun.l.google.com:19302' }\n        ]\n      };\n    }\n  }\n\n  async enumerateDevices() {\n    // Only enumerate devices if mediaDevices is available\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      console.warn('MediaDevices API not available');\n      return;\n    }\n\n    try {\n\n      // Request microphone access first to get permissions\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          }\n        });\n        // Stop the stream immediately after getting permissions\n        stream.getTracks().forEach(track => track.stop());\n        console.log('Microphone access granted for device enumeration');\n      } catch (micError) {\n        // Continue anyway - some devices might still be enumerable\n      }\n\n      // Now enumerate devices\n      const devices = await navigator.mediaDevices.enumerateDevices();\n\n      this.inputDevices = devices\n        .filter(device => device.kind === 'audioinput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Microphone' : 'Unknown Microphone')\n        }));\n\n      this.outputDevices = devices\n        .filter(device => device.kind === 'audiooutput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Speaker' : 'Unknown Speaker')\n        }));\n\n      \n\n      if (!this.selectedInputDeviceId && this.inputDevices.length > 0) {\n        this.selectedInputDeviceId = this.inputDevices[0].deviceId || 'default';\n      }\n      if (!this.selectedOutputDeviceId && this.outputDevices.length > 0) {\n        this.selectedOutputDeviceId = this.outputDevices[0].deviceId || 'default';\n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    } catch (error) {\n      console.error('Error enumerating devices:', error);\n\n      // If enumeration fails, try to get basic device info\n      if (error.name === 'NotAllowedError') {\n        // User denied permission, but we can still show default devices\n        this.inputDevices = [{\n          deviceId: 'default',\n          label: 'Default Microphone'\n        }];\n        this.outputDevices = [{\n          deviceId: 'default',\n          label: 'Default Speaker'\n        }];\n        \n      } else {\n        // For other errors, show placeholder devices\n        this.inputDevices = [{\n          deviceId: '',\n          label: 'No microphone detected'\n        }];\n        this.outputDevices = [{\n          deviceId: '',\n          label: 'No speaker detected'\n        }];\n        \n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    }\n  }\n\n  async setupWebRTC() {\n    if (!this.audioOutputElement) {\n      console.error(\"Audio output element not found\");\n      return;\n    }\n\n    try {\n      const constraints = {\n        audio: this.selectedInputDeviceId ? {\n          deviceId: { exact: this.selectedInputDeviceId },\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        } : {\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        },\n      };\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      \n\n      this.currentStream = stream;\n      this.peerConnection = new RTCPeerConnection(await this.getTurnCredentials());\n\n      // Add tracks to peer connection\n      stream.getTracks().forEach(track => {\n        this.peerConnection.addTrack(track, stream);\n      });\n\n      // Handle remote tracks\n      this.peerConnection.addEventListener(\"track\", (evt) => {\n\n        if (evt.track.kind === 'audio') {\n          if (this.audioOutputElement) {\n            if (this.audioOutputElement.srcObject !== evt.streams[0]) {\n              // New remote stream attached; reset playback flag so we re-trigger play()\n              this.playbackStarted = false;\n              this.audioOutputElement.srcObject = evt.streams[0];\n\n              // Set volume and unmute\n              this.audioOutputElement.volume = 1.0;\n              this.audioOutputElement.muted = false;\n              // Defer to unified playback handler to avoid multiple play() calls\n              this.ensurePlayback();\n            } else {\n              \n            }\n          } else {\n            console.error(\"âŒ Audio element not found!\");\n          }\n        } else {\n          \n        }\n      });\n\n      // Create data channel\n      this.dataChannel = this.peerConnection.createDataChannel(\"text\");\n      this.dataChannel.onopen = () => {\n        // If data channel opens and we're not marked as connected, force connection state\n        if (!this.isWebRTCConnected) {\n          this.isWebRTCConnected = true;\n          this.isConnecting = false;\n          this.updateUI();\n\n          // Force unmute audio element when data channel opens\n          this.forceUnmuteAudio();\n        }\n      };\n      this.dataChannel.onclose = () => {};\n      this.dataChannel.onerror = (error) => console.error(\"Data channel error:\", error);\n      this.dataChannel.onmessage = (event) => {\n        // If we receive data channel messages and we're not marked as connected, force connection state\n        if (!this.isWebRTCConnected) {\n          this.isWebRTCConnected = true;\n          this.updateUI();\n\n          // Force unmute audio element when data channel messages arrive\n          this.forceUnmuteAudio();\n        }\n      };\n\n      // Create offer\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n\n      const randomId = Math.random().toString(36).substring(7);\n      const webrtcId = randomId;\n\n      // Handle ICE candidates\n      this.peerConnection.onicecandidate = ({ candidate }) => {\n        if (candidate) {\n          fetch(`${this.apiUrl}/webrtc/offer`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n              candidate: candidate.toJSON(),\n              webrtc_id: webrtcId,\n              type: \"ice-candidate\",\n            })\n          });\n        }\n      };\n\n      this.peerConnection.oniceconnectionstatechange = () => {\n\n        // If ICE is connected and we have data channel messages, consider it connected\n        if (this.peerConnection.iceConnectionState === 'connected' ||\n            this.peerConnection.iceConnectionState === 'completed') {\n          if (!this.isWebRTCConnected) {\n            this.isWebRTCConnected = true;\n            this.isConnecting = false;\n            this.updateUI();\n\n            // Force unmute audio element when ICE connected\n            this.forceUnmuteAudio();\n          }\n        } else if (this.peerConnection.iceConnectionState === 'failed' ||\n                   this.peerConnection.iceConnectionState === 'disconnected') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        }\n      };\n\n      this.peerConnection.onconnectionstatechange = () => {\n\n        if (this.peerConnection.connectionState === 'connected') {\n          this.isWebRTCConnected = true;\n          this.isConnecting = false;\n          this.updateUI();\n\n          // Force unmute audio element when connected\n          this.forceUnmuteAudio();\n        } else if (this.peerConnection.connectionState === 'connecting') {\n          \n        } else if (this.peerConnection.connectionState === 'new') {\n          \n        } else if (this.peerConnection.connectionState === 'failed') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        } else if (this.peerConnection.connectionState === 'disconnected' ||\n                   this.peerConnection.connectionState === 'closed') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        }\n      };\n\n      // Send offer to server\n      const response = await fetch(`${this.apiUrl}/webrtc/offer`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          sdp: offer.sdp,\n          type: offer.type,\n          webrtc_id: webrtcId\n        })\n      });\n\n      let serverResponse;\n      try {\n        serverResponse = await response.json();\n\n        // Validate server response\n        if (!serverResponse || typeof serverResponse !== 'object') {\n          throw new Error('Invalid server response: not an object');\n        }\n\n        if (!serverResponse.sdp || !serverResponse.type) {\n          throw new Error('Invalid server response: missing sdp or type');\n        }\n\n        // Create proper RTCSessionDescription object\n        const answer = new RTCSessionDescription({\n          type: serverResponse.type,\n          sdp: serverResponse.sdp\n        });\n\n        await this.peerConnection.setRemoteDescription(answer);\n\n      } catch (parseError) {\n        // Handle JSON parsing errors or validation errors\n        console.error(\"Error parsing server response:\", parseError);\n        console.error(\"Server response was:\", serverResponse);\n        throw new Error(`Failed to parse server response: ${parseError.message}`);\n      }\n\n    } catch (error) {\n      console.error(\"Error in WebRTC setup process:\", error);\n\n      // Provide more specific error messages\n      if (error.name === 'NotAllowedError') {\n        alert(\"Microphone access denied. Please allow microphone access in your browser settings.\");\n      } else if (error.name === 'NotFoundError') {\n        alert(\"No microphone found. Please connect a microphone and try again.\");\n      } else if (error.name === 'NotReadableError') {\n        alert(\"Microphone is in use by another application. Please close other apps using the microphone.\");\n      } else if (error.message.includes('Failed to parse SessionDescription')) {\n        alert(\"WebRTC connection failed: Invalid server response. Please check your WebRTC backend.\");\n        console.error(\"Server response was:\", serverResponse);\n      } else {\n        alert(\"WebRTC connection failed: \" + error.message);\n      }\n\n      // Clean up on error\n      this.isWebRTCConnected = false;\n      this.updateUI();\n    }\n  }\n\n  async shutdownWebRTC() {\n    console.log(\"Shutting down WebRTC connection...\");\n\n    if (this.peerConnection) {\n      const senders = this.peerConnection.getSenders();\n      senders.forEach(sender => {\n        if (sender.track) {\n          console.log(`Stopping track: ${sender.track.kind}`);\n          sender.track.stop();\n        }\n      });\n\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.currentStream) {\n      this.currentStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.currentStream = null;\n    }\n\n    console.log(\"WebRTC connection closed and microphone access released.\");\n    this.isWebRTCConnected = false;\n    this.updateUI();\n  }\n\n  async handleToggleVoiceChat() {\n    if (this.isWebRTCConnected) {\n      await this.shutdownWebRTC();\n    } else {\n      if (this.isConnecting) {\n        console.log(\"Connection attempt already in progress.\");\n        return;\n      }\n\n      // RTCPeerConnection will be created inside setupWebRTC()\n\n      this.isConnecting = true;\n      this.updateUI();\n      console.log(\"Attempting to start voice chat setup...\");\n\n      try {\n        await this.setupWebRTC();\n        // Don't reset isConnecting here - let the event handlers in setupWebRTC() handle state transitions\n        // The connection state will be managed by the ICE/connection state change handlers\n      } catch (error) {\n        console.error(\"Error during setupWebRTC:\", error);\n        // Only reset connecting state on actual error\n        this.isConnecting = false;\n        this.updateUI();\n      }\n      // Note: If setupWebRTC() succeeds, the event handlers will set isWebRTCConnected = true\n      // and isConnecting = false, which will trigger UI updates automatically\n    }\n  }\n\n  async handleInputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid input device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.inputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected input device info:', selected || { deviceId, note: 'Not found in inputDevices' });\n\n    this.selectedInputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    // If we're connected, we need to replace the input track\n    if (this.isWebRTCConnected && this.peerConnection && this.currentStream) {\n      try {\n        console.log(`Switching input device to: ${deviceId}`);\n\n        // Get new stream with selected device\n        const constraints = {\n          audio: deviceId && deviceId !== 'default' ? {\n            deviceId: { exact: deviceId },\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          } : {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          },\n        };\n\n        const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n        console.log(\"New microphone stream obtained.\");\n\n        // Stop old tracks\n        this.currentStream.getTracks().forEach(track => {\n          track.stop();\n        });\n\n        // Replace tracks in peer connection\n        const sender = this.peerConnection.getSenders().find(s =>\n          s.track && s.track.kind === 'audio'\n        );\n\n        if (sender && newStream.getAudioTracks().length > 0) {\n          await sender.replaceTrack(newStream.getAudioTracks()[0]);\n          console.log(\"Audio track replaced successfully.\");\n        } else {\n          console.error(\"Could not find audio sender or new audio track.\");\n        }\n\n        // Update stream reference\n        this.currentStream = newStream;\n\n      } catch (error) {\n        console.error('Error changing input device during connection:', error);\n        // Try to revert the device selection if it failed\n        const originalDevice = this.selectedInputDeviceId;\n        this.selectedInputDeviceId = originalDevice;\n        this.updateDeviceMenus();\n      }\n    }\n  }\n\n  async handleOutputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid output device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.outputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected output device info:', selected || { deviceId, note: 'Not found in outputDevices' });\n\n    this.selectedOutputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    if (this.audioOutputElement && this.audioOutputElement.setSinkId) {\n      try {\n        // Only try to set sink ID if it's not the default device\n        if (deviceId !== 'default') {\n          await this.audioOutputElement.setSinkId(deviceId);\n          console.log(`Audio output device changed to: ${deviceId}`);\n        } else {\n          console.log('Using default audio output device');\n        }\n      } catch (error) {\n        console.error('Error setting audio output device:', error);\n      }\n    } else {\n      console.warn('Audio output device change not supported in this browser');\n    }\n  }\n\n  async handleMuteToggle() {\n    if (!this.isWebRTCConnected || !this.peerConnection || !this.currentStream) {\n      console.warn('Cannot toggle mute - not connected or no stream');\n      return;\n    }\n\n    try {\n      // Get all audio tracks from the current stream\n      const audioTracks = this.currentStream.getAudioTracks();\n\n      if (audioTracks.length === 0) {\n        console.warn('No audio tracks found in current stream');\n        return;\n      }\n\n      // Toggle mute state\n      this.isMicMuted = !this.isMicMuted;\n\n      // Enable/disable all audio tracks (this stops/starts sending audio)\n      audioTracks.forEach(track => {\n        track.enabled = !this.isMicMuted;\n      });\n\n      console.log(`Microphone ${this.isMicMuted ? 'muted' : 'unmuted'}`);\n\n      // Find the audio sender in the peer connection\n      const sender = this.peerConnection.getSenders().find(s =>\n        s.track && s.track.kind === 'audio'\n      );\n\n      if (sender) {\n        // Update the sender to reflect the mute state\n        // The track.enabled property change should be sufficient\n        // but we can also update the sender if needed\n        console.log('Audio sender found, mute state updated');\n      }\n\n      this.updateUI();\n    } catch (error) {\n      console.error('Error toggling mute:', error);\n      // Revert the state if there was an error\n      this.isMicMuted = !this.isMicMuted;\n      this.updateUI();\n    }\n  }\n\n  // UI functionality\n  render() {\n    const container = document.createElement('div');\n    container.className = 'widget-container';\n\n    const style = document.createElement('style');\n    style.textContent = `\n      .widget-container {\n        display: inline-flex;\n        align-items: center;\n        gap: 12px;\n        ${this.isDarkMode ? `\n          background: #1f2937;\n          border: 1px solid #374151;\n        ` : `\n          background: #ffffff;\n          border: 1px solid #e5e7eb;\n        `}\n        border-radius: 24px;\n        padding: 8px 16px 8px 12px;\n        ${this.isDarkMode ? `\n          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\n        ` : `\n          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n        `}\n        font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        box-sizing: border-box;\n        position: relative;\n        transition: all 0.2s ease;\n        max-width: 320px;\n        min-width: 200px;\n      }\n\n      .widget-container:hover {\n        ${this.isDarkMode ? `\n          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);\n        ` : `\n          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n        `}\n      }\n\n      .widget-buttons {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n      }\n\n      .mic-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 40px;\n        height: 40px;\n        border-radius: 50%;\n        ${this.isDarkMode ? `\n          background: #1f2937;\n          border: 2px solid #374151;\n        ` : `\n          background: #ffffff;\n          border: 2px solid #e5e7eb;\n        `}\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n        flex-shrink: 0;\n      }\n\n      .mic-button.active {\n        ${this.isDarkMode ? `\n          background: #dc2626;\n          border-color: #b91c1c;\n        ` : `\n          background: #ef4444;\n          border-color: #dc2626;\n        `}\n        color: #ffffff;\n      }\n\n      .mic-button.connecting {\n        ${this.isDarkMode ? `\n          background: #d97706;\n          border-color: #b45309;\n        ` : `\n          background: #f59e0b;\n          border-color: #d97706;\n        `}\n        color: #ffffff;\n      }\n\n      .mic-button.muted {\n        background: #fbbf24;\n        ${this.isDarkMode ? `\n          border-color: #d97706;\n        ` : `\n          border-color: #f59e0b;\n        `}\n        ${this.isDarkMode ? `\n          color: #111827 !important;\n        ` : `\n          color: #111827 !important;\n        `}\n      }\n\n      .mic-button.muted svg, .mic-button.muted svg * {\n        ${this.isDarkMode ? `\n          stroke: #111827 !important;\n        ` : `\n          stroke: #111827 !important;\n        `}\n      }\n\n      /* Call button (idle state) - plain/neutral */\n      .mic-button:not(.active):not(.connecting):not(.muted) {\n        ${this.isDarkMode ? `\n          background: #1f2937;\n          border-color: #374151;\n          color: #f9fafb;\n        ` : `\n          background: #ffffff;\n          border-color: #e5e7eb;\n          color: #374151;\n        `}\n      }\n\n      .mic-button:not(.active):not(.connecting):not(.muted) svg {\n        ${this.isDarkMode ? `\n          color: #f9fafb;\n        ` : `\n          color: #374151;\n        `}\n      }\n\n      .mic-button:hover {\n        transform: scale(1.05);\n      }\n\n      .mic-button:disabled {\n        opacity: 0.6;\n        cursor: not-allowed;\n        transform: none;\n      }\n\n      .text-container {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        gap: 2px;\n        min-width: 0;\n      }\n\n      .primary-text {\n        font-size: 13px;\n        font-weight: 500;\n        ${this.isDarkMode ? `\n          color: #f9fafb;\n        ` : `\n          color: #111827;\n        `}\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .secondary-text {\n        font-size: 11px;\n        ${this.isDarkMode ? `\n          color: #d1d5db;\n        ` : `\n          color: #6b7280;\n        `}\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .menu-container {\n        position: absolute;\n        top: 50%;\n        right: 8px;\n        transform: translateY(-50%);\n        z-index: 10;\n      }\n\n      .settings-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 32px;\n        height: 32px;\n        border-radius: 50%;\n        ${this.isDarkMode ? `\n          background: #111827;\n          color: #f9fafb;\n        ` : `\n          background: #f3f4f6;\n          color: #374151;\n        `}\n        border: none;\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n      }\n\n      .settings-button:hover {\n        ${this.isDarkMode ? `\n          background: #374151;\n          color: #f9fafb;\n        ` : `\n          background: #e5e7eb;\n          color: #374151;\n        `}\n      }\n\n      .settings-button svg {\n        ${this.isDarkMode ? `\n          color: #f9fafb;\n        ` : `\n          color: #374151;\n        `}\n      }\n\n      .device-menu {\n        position: absolute;\n        ${this.isDarkMode ? `\n          background: #1f2937;\n          border: 1px solid #374151;\n        ` : `\n          background: white;\n          border: 1px solid #e5e7eb;\n        `}\n        border-radius: 8px;\n        ${this.isDarkMode ? `\n          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);\n        ` : `\n          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n        `}\n        min-width: 200px;\n        z-index: 1000;\n        display: none;\n      }\n\n      /* Device menu positioning */\n      .device-menu[data-position=\"top\"] {\n        bottom: calc(100% + 4px);\n        right: 0;\n        transform: none;\n      }\n\n      .device-menu[data-position=\"top-left\"] {\n        bottom: calc(100% + 4px);\n        right: 0;\n        transform: none;\n      }\n\n      .device-menu[data-position=\"top-right\"] {\n        bottom: calc(100% + 4px);\n        left: 0;\n        transform: none;\n      }\n\n      .device-menu[data-position=\"bottom\"] {\n        top: calc(100% + 4px);\n        right: 0;\n        transform: none;\n      }\n\n      .device-menu[data-position=\"bottom-left\"] {\n        top: calc(100% + 4px);\n        right: 0;\n        transform: none;\n      }\n\n      .device-menu[data-position=\"bottom-right\"] {\n        top: calc(100% + 4px);\n        left: 0;\n        transform: none;\n      }\n\n      .device-menu.open {\n        display: block;\n      }\n\n      .device-menu-section {\n        padding: 8px;\n      }\n\n      .device-menu-label {\n        font-size: 9px;\n        font-weight: 500;\n        ${this.isDarkMode ? `\n          color: #9ca3af;\n        ` : `\n          color: #9ca3af;\n        `}\n        text-transform: uppercase;\n        letter-spacing: 0.05em;\n        padding: 0 8px 4px;\n      }\n\n      .device-option {\n        display: flex;\n        align-items: center;\n        padding: 8px;\n        cursor: pointer;\n        border-radius: 4px;\n        transition: background-color 0.15s ease;\n      }\n\n      .device-option:hover {\n        ${this.isDarkMode ? `\n          background-color: #374151;\n        ` : `\n          background-color: #f3f4f6;\n        `}\n      }\n\n      .device-option.selected {\n        ${this.isDarkMode ? `\n          background-color: #3b82f6;\n        ` : `\n          background-color: #eff6ff;\n        `}\n        color: #ffffff;\n      }\n\n      .device-option.selected label {\n        color: #ffffff;\n        font-weight: 500;\n      }\n\n      .device-option input[type=\"radio\"] {\n        margin-right: 8px;\n      }\n\n      .device-option label {\n        flex: 1;\n        cursor: pointer;\n        font-size: 11px;\n        ${this.isDarkMode ? `\n          color: #d1d5db;\n        ` : `\n          color: #6b7280;\n        `}\n      }\n\n      .audio-element {\n        position: absolute;\n        visibility: hidden;\n        width: 1px;\n        height: 1px;\n        pointer-events: none;\n        opacity: 0;\n      }\n\n      .audio-element[autoplay] {\n        /* Ensure autoplay works */\n      }\n\n      .hidden {\n        display: none !important;\n      }\n\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n\n      .connecting-animation {\n        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n      }\n\n      .sr-only {\n        position: absolute;\n        width: 1px;\n        height: 1px;\n        padding: 0;\n        margin: -1px;\n        overflow: hidden;\n        clip: rect(0, 0, 0, 0);\n        white-space: nowrap;\n        border: 0;\n      }\n    `;\n\n    // Create the main button\n    const micButton = document.createElement('button');\n    micButton.className = `mic-button ${this.isWebRTCConnected ? 'active' : ''} ${this.isConnecting ? 'connecting' : ''}`;\n    micButton.setAttribute('aria-label', this.isWebRTCConnected ? 'Stop voice chat' : 'Start voice chat');\n    micButton.setAttribute('data-role', 'call');\n\n    if (this.isConnecting && !this.isWebRTCConnected) {\n      micButton.classList.add('connecting-animation');\n    }\n\n    // Add screen reader text\n    const srText = document.createElement('span');\n    srText.className = 'sr-only';\n    srText.textContent = this.isWebRTCConnected ? 'Stop Voice Chat' : 'Start Voice Chat';\n\n    // Add icons based on state (Lucide-style SVGs)\n    const callIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-icon lucide-phone\"><path d=\"M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384\"/></svg>'\n      \n    micButton.innerHTML = callIcon;\n    micButton.appendChild(srText);\n\n    // Create text container\n    const textContainer = document.createElement('div');\n    textContainer.className = 'text-container';\n\n    const primaryText = document.createElement('p');\n    primaryText.className = 'primary-text';\n    primaryText.textContent = (this.isConnecting && !this.isWebRTCConnected) ? 'Connecting...' : this.isWebRTCConnected ? 'Connected' : 'Click to start!';\n\n    const secondaryText = document.createElement('p');\n    secondaryText.className = 'secondary-text';\n    secondaryText.textContent = 'Click to disconnect';\n    if (!this.isWebRTCConnected) {\n      secondaryText.style.display = 'none';\n    }\n\n    textContainer.appendChild(primaryText);\n    textContainer.appendChild(secondaryText);\n\n    // Create device menu if needed\n    let menuContainer = null;\n    if (this.showDeviceSelection) {\n      menuContainer = document.createElement('div');\n      menuContainer.className = 'menu-container';\n\n      const settingsButton = document.createElement('button');\n      settingsButton.className = 'settings-button';\n      settingsButton.setAttribute('aria-label', 'Device settings');\n      settingsButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-settings-icon lucide-settings\"><path d=\"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915\"/><circle cx=\"12\" cy=\"12\" r=\"3\"/></svg>';\n\n      const deviceMenu = document.createElement('div');\n      deviceMenu.className = 'device-menu';\n      deviceMenu.setAttribute('data-position', this.menuPosition);\n      this.buildDeviceMenuContent(deviceMenu);\n\n      settingsButton.addEventListener('click', async (e) => {\n        e.stopPropagation();\n\n        // If devices haven't been enumerated yet, do it now\n        if (this.inputDevices.length === 0 && this.outputDevices.length === 0) {\n          console.log('Settings button clicked - enumerating devices...');\n          await this.enumerateDevices();\n        }\n\n        deviceMenu.classList.toggle('open');\n      });\n\n      // Close menu when clicking outside\n      document.addEventListener('click', (e) => {\n        if (!menuContainer.contains(e.target)) {\n          deviceMenu.classList.remove('open');\n        }\n      });\n\n      menuContainer.appendChild(settingsButton);\n      menuContainer.appendChild(deviceMenu);\n    }\n\n    // Create expanded state buttons if connected\n    if (this.isWebRTCConnected) {\n      const buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'widget-buttons';\n\n      // Hang up button (red)\n      const hangUpButton = document.createElement('button');\n      hangUpButton.className = 'mic-button active';\n      hangUpButton.setAttribute('aria-label', 'Hang up');\n      hangUpButton.setAttribute('data-role', 'hangup');\n      hangUpButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-off-icon lucide-phone-off\"><path d=\"M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272\"/><path d=\"M22 2 2 22\"/><path d=\"M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473\"/></svg>'\n\n      // Mute button\n      const muteButton = document.createElement('button');\n      muteButton.className = `mic-button ${this.isMicMuted ? 'muted' : ''}`;\n      muteButton.setAttribute('aria-label', this.isMicMuted ? 'Unmute microphone' : 'Mute microphone');\n      muteButton.setAttribute('data-role', 'mute');\n      muteButton.innerHTML = this.isMicMuted\n        ? '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-off-icon lucide-mic-off\"><path d=\"M12 19v3\"/><path d=\"M15 9.34V5a3 3 0 0 0-5.68-1.33\"/><path d=\"M16.95 16.95A7 7 0 0 1 5 12v-2\"/><path d=\"M18.89 13.23A7 7 0 0 0 19 12v-2\"/><path d=\"m2 2 20 20\"/><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12\"/></svg>'\n        : '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-icon lucide-mic\"><path d=\"M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\"/><path d=\"M19 10v1a7 7 0 0 1-14 0v-1\"/><path d=\"M12 19v3\"/><path d=\"M8 22h8\"/></svg>'\n      buttonsContainer.appendChild(hangUpButton);\n      buttonsContainer.appendChild(muteButton);\n      container.appendChild(buttonsContainer);\n    } else {\n      container.appendChild(micButton);\n    }\n\n    container.appendChild(textContainer);\n\n    if (menuContainer) {\n      // Position the menu container absolutely over the button area\n      container.style.position = 'relative';\n      container.appendChild(menuContainer);\n    }\n\n    // Hidden audio element with autoplay for remote stream (preserve across re-renders)\n    const existingAudioElement = this.audioOutputElement;\n    const existingStream = existingAudioElement?.srcObject || null;\n\n    if (existingAudioElement) {\n      this.audioOutputElement = existingAudioElement;\n    } else {\n      this.audioOutputElement = document.createElement('audio');\n      this.audioOutputElement.className = 'audio-element';\n      this.audioOutputElement.id = 'fastrtcvoice-widget-audio';\n      this.audioOutputElement.autoplay = true;\n      this.audioOutputElement.playsInline = true;\n      this.audioOutputElement.controls = false;\n      this.audioOutputElement.muted = false;\n      this.audioOutputElement.volume = 1.0;\n\n    // Add debugging events to audio element (only once per element)\n      this.audioOutputElement.addEventListener('error', (e) => {\n        console.error('Audio element error:', e);\n      });\n    }\n\n    // Add click handler to the widget container to enable audio playback (once)\n    if (!this.shadowClickListenerAdded) {\n      this.shadowRoot.addEventListener('click', () => {\n        if (this.audioOutputElement) {\n          if (this.audioOutputElement.muted) {\n            console.log('ðŸ”Š User clicked widget - attempting to unmute audio');\n            this.forceUnmuteAudio();\n          }\n          this.ensurePlayback();\n        }\n      });\n      this.shadowClickListenerAdded = true;\n    }\n\n    container.appendChild(this.audioOutputElement);\n\n    // If there was an existing stream attached before re-render, ensure it remains attached\n    if (existingStream && !this.audioOutputElement.srcObject) {\n      this.audioOutputElement.srcObject = existingStream;\n    }\n\n    this.shadowRoot.innerHTML = '';\n    this.shadowRoot.appendChild(style);\n    this.shadowRoot.appendChild(container);\n  }\n\n  updateUI() {\n    this.render();\n    this.setupEventListeners();\n  }\n\n  updateDeviceMenus() {\n    // This would update the radio button states in the device menu\n    const deviceMenu = this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      const inputRadios = deviceMenu.querySelectorAll('input[name=\"input-device\"]');\n      const outputRadios = deviceMenu.querySelectorAll('input[name=\"output-device\"]');\n\n      inputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedInputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n\n      outputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedOutputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n    }\n  }\n\n  buildDeviceMenuContent(deviceMenu) {\n    if (!deviceMenu) return;\n\n    // Clear existing content\n    deviceMenu.innerHTML = '';\n\n    // Input devices section\n    const inputSection = document.createElement('div');\n    inputSection.className = 'device-menu-section';\n\n    const inputLabel = document.createElement('div');\n    inputLabel.className = 'device-menu-label';\n    inputLabel.textContent = 'Input Device';\n    inputSection.appendChild(inputLabel);\n\n    this.inputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedInputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'input-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedInputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleInputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      inputSection.appendChild(option);\n    });\n\n    // Output devices section\n    const outputSection = document.createElement('div');\n    outputSection.className = 'device-menu-section';\n\n    const outputLabel = document.createElement('div');\n    outputLabel.className = 'device-menu-label';\n    outputLabel.textContent = 'Output Device';\n    outputSection.appendChild(outputLabel);\n\n    this.outputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedOutputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'output-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedOutputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleOutputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      outputSection.appendChild(option);\n    });\n\n    deviceMenu.appendChild(inputSection);\n    deviceMenu.appendChild(outputSection);\n  }\n\n  rebuildDeviceMenu() {\n    const deviceMenu = this.shadowRoot && this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      this.buildDeviceMenuContent(deviceMenu);\n    }\n  }\n\n  setupEventListeners() {\n    // Main mic button (for start/stop)\n    const micButton = this.shadowRoot.querySelector('.mic-button[data-role=\"call\"]');\n    if (micButton) {\n      micButton.addEventListener('click', () => this.handleToggleVoiceChat());\n    }\n\n    // Hang up button (red)\n    const hangUpButton = this.shadowRoot.querySelector('.mic-button[data-role=\"hangup\"]');\n    if (hangUpButton && !hangUpButton.hasEventListener) {\n      hangUpButton.addEventListener('click', () => this.handleToggleVoiceChat());\n      hangUpButton.hasEventListener = true;\n    }\n\n    // Mute button (toggle)\n    const muteButton = this.shadowRoot.querySelector('.mic-button[data-role=\"mute\"]');\n    if (muteButton && !muteButton.hasEventListener) {\n      muteButton.addEventListener('click', () => {\n        this.handleMuteToggle();\n        // Update icon and class immediately to reflect state\n        const isMutedNow = this.isMicMuted;\n        muteButton.classList.toggle('muted', isMutedNow);\n        muteButton.setAttribute('aria-label', isMutedNow ? 'Unmute microphone' : 'Mute microphone');\n        muteButton.innerHTML = isMutedNow\n          ? '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-off-icon lucide-mic-off\"><path d=\"M12 19v3\"/><path d=\"M15 9.34V5a3 3 0 0 0-5.68-1.33\"/><path d=\"M16.95 16.95A7 7 0 0 1 5 12v-2\"/><path d=\"M18.89 13.23A7 7 0 0 0 19 12v-2\"/><path d=\"m2 2 20 20\"/><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12\"/></svg>'\n          : '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-icon lucide-mic\"><path d=\"M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\"/><path d=\"M19 10v1a7 7 0 0 1-14 0v-1\"/><path d=\"M12 19v3\"/><path d=\"M8 22h8\"/></svg>';\n      });\n      muteButton.hasEventListener = true;\n    }\n  }\n\n  cleanup() {\n    this.shutdownWebRTC();\n\n    if (this.audioOutputElement) {\n      console.log('Cleaning up audio element');\n      this.audioOutputElement.srcObject = null;\n      this.audioOutputElement.pause();\n    }\n    this.playbackStarted = false;\n  }\n\n  // Force unmute audio element with multiple techniques\n  forceUnmuteAudio() {\n    if (!this.audioOutputElement) {\n      console.error('Audio element not found');\n      return;\n    }\n\n    // Method 1: Direct property setting\n    this.audioOutputElement.muted = false;\n    this.audioOutputElement.volume = 1.0;\n\n    // Method 2: Try to set sink ID (for output device control)\n    if (this.audioOutputElement.setSinkId && this.selectedOutputDeviceId) {\n      this.audioOutputElement.setSinkId(this.selectedOutputDeviceId).catch(() => {});\n    }\n\n    // Method 3: Delegate actual playback to a single unified handler\n    \n\n    this.ensurePlayback();\n    \n  }\n\n  // Ensure playback starts only once to avoid overlapping play() calls\n  ensurePlayback() {\n    if (!this.audioOutputElement || this.playbackStarted === true) return;\n    if (!this.audioOutputElement.srcObject) return;\n\n    if (this.audioOutputElement.paused) {\n      const playPromise = this.audioOutputElement.play();\n      if (playPromise !== undefined) {\n        playPromise.then(() => {\n          this.playbackStarted = true;\n        }).catch(error => {\n          \n        });\n      }\n    } else {\n      this.playbackStarted = true;\n    }\n  }\n\n  // Debug method to check audio status\n  debugAudioStatus() {\n    console.group('ðŸ”Š Audio Status Debug');\n    console.log('Audio element exists:', !!this.audioOutputElement);\n    console.log('Audio element muted:', this.audioOutputElement?.muted);\n    console.log('Audio element volume:', this.audioOutputElement?.volume);\n    console.log('Audio element srcObject:', this.audioOutputElement?.srcObject);\n    console.log('Audio element paused:', this.audioOutputElement?.paused);\n    console.log('Audio element readyState:', this.audioOutputElement?.readyState);\n    console.log('WebRTC connected:', this.isWebRTCConnected);\n    console.log('Peer connection state:', this.peerConnection?.connectionState);\n    console.log('Current stream tracks:', this.currentStream?.getTracks().length || 0);\n    console.log('Peer connection senders:', this.peerConnection?.getSenders().length || 0);\n\n    if (this.peerConnection) {\n      const receivers = this.peerConnection.getReceivers();\n      console.log('Peer connection receivers:', receivers.length);\n      receivers.forEach((receiver, index) => {\n        console.log(`Receiver ${index}:`, {\n          track: receiver.track ? {\n            kind: receiver.track.kind,\n            id: receiver.track.id,\n            enabled: receiver.track.enabled,\n            readyState: receiver.track.readyState\n          } : null\n        });\n      });\n    }\n\n    if (this.audioOutputElement?.srcObject) {\n      const stream = this.audioOutputElement.srcObject;\n      console.log('Audio stream details:', {\n        id: stream.id,\n        active: stream.active,\n        tracks: stream.getTracks().map(t => ({\n          kind: t.kind,\n          id: t.id,\n          enabled: t.enabled,\n          readyState: t.readyState\n        }))\n      });\n    }\n\n    console.groupEnd();\n  }\n}\n\n// Register the web component\nif (!customElements.get('fastrtcvoice-widget')) {\n  customElements.define('fastrtcvoice-widget', FastRTCVoiceWidget);\n}\n\n// Rely on the browser's native custom element upgrade lifecycle\n\n// Export for use in other contexts\nwindow.FastRTCVoiceWidget = FastRTCVoiceWidget;\n"],"names":["FastRTCVoiceWidget","HTMLElement","constructor","super","this","attachShadow","mode","isWebRTCConnected","isConnecting","peerConnection","currentStream","dataChannel","audioOutputElement","shadowClickListenerAdded","playbackStarted","debugEnabled","inputDevices","outputDevices","selectedInputDeviceId","selectedOutputDeviceId","isExpanded","isMicMuted","menuPosition","isDarkMode","observedAttributes","attributeChangedCallback","name","oldValue","newValue","hasAttribute","getAttribute","includes","render","debugLog","args","console","log","connectedCallback","apiUrl","authToken","showDeviceSelection","setupEventListeners","error","disconnectedCallback","cleanup","getTurnCredentials","response","fetch","headers","ok","Error","status","json","iceServers","urls","enumerateDevices","navigator","mediaDevices","getUserMedia","audio","noiseSuppression","echoCancellation","autoGainControl","getTracks","forEach","track","stop","micError","devices","filter","device","kind","map","deviceId","label","trim","length","rebuildDeviceMenu","updateDeviceMenus","warn","setupWebRTC","constraints","exact","stream","RTCPeerConnection","addTrack","addEventListener","evt","srcObject","streams","volume","muted","ensurePlayback","createDataChannel","onopen","updateUI","forceUnmuteAudio","onclose","onerror","onmessage","event","offer","createOffer","setLocalDescription","webrtcId","Math","random","toString","substring","onicecandidate","candidate","method","body","JSON","stringify","toJSON","webrtc_id","type","oniceconnectionstatechange","iceConnectionState","onconnectionstatechange","connectionState","sdp","serverResponse","answer","RTCSessionDescription","setRemoteDescription","parseError","message","alert","shutdownWebRTC","getSenders","sender","close","handleToggleVoiceChat","handleInputDeviceChange","selected","find","d","note","newStream","s","getAudioTracks","replaceTrack","originalDevice","handleOutputDeviceChange","setSinkId","handleMuteToggle","audioTracks","enabled","container","document","createElement","className","style","textContent","micButton","setAttribute","classList","add","srText","innerHTML","appendChild","textContainer","primaryText","secondaryText","display","menuContainer","settingsButton","deviceMenu","buildDeviceMenuContent","async","e","stopPropagation","toggle","contains","target","remove","buttonsContainer","hangUpButton","muteButton","position","existingAudioElement","existingStream","id","autoplay","playsInline","controls","shadowRoot","querySelector","inputRadios","querySelectorAll","outputRadios","radio","checked","value","closest","inputSection","inputLabel","option","outputSection","outputLabel","hasEventListener","isMutedNow","pause","catch","paused","playPromise","play","then","debugAudioStatus","group","_a","_b","_c","_d","_e","readyState","_f","_g","_h","receivers","getReceivers","receiver","index","_i","active","tracks","t","groupEnd","customElements","get","define","window"],"mappings":"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"}
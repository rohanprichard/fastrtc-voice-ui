{"version":3,"file":"fastrtc-voice-widget.umd.js","sources":["../src/widget.js"],"sourcesContent":["// FastRTC Voice Widget - Language-agnostic embeddable widget\nclass FastRTCVoiceWidget extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.isWebRTCConnected = false;\n    this.isConnecting = false;\n    this.peerConnection = null;\n    this.currentStream = null;\n    this.dataChannel = null;\n    this.audioOutputElement = null;\n\n    // Device state\n    this.inputDevices = [];\n    this.outputDevices = [];\n    this.selectedInputDeviceId = '';\n    this.selectedOutputDeviceId = '';\n\n    // UI state\n    this.isExpanded = false;\n    this.isMicMuted = false;\n  }\n\n  connectedCallback() {\n    try {\n      this.apiUrl = this.getAttribute('api-url') || '';\n      this.authToken = this.getAttribute('auth-token') || '';\n      this.showDeviceSelection = this.hasAttribute('show-device-selection');\n\n    // Check for demo attributes\n    if (this.hasAttribute('is-connected')) {\n      this.isWebRTCConnected = true;\n    }\n\n      this.render();\n      this.setupEventListeners();\n      // Device enumeration now happens only when settings button is clicked\n    } catch (error) {\n      console.error('Error in connectedCallback:', error);\n    }\n  }\n\n  disconnectedCallback() {\n    this.cleanup();\n  }\n\n  // WebRTC functionality\n  async getTurnCredentials() {\n    try {\n      const response = await fetch(`${this.apiUrl}/webrtc/turn-credentials`, {\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get TURN credentials: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching TURN credentials:', error);\n      return {\n        iceServers: [\n          { urls: 'stun:stun.l.google.com:19302' }\n        ]\n      };\n    }\n  }\n\n  async enumerateDevices() {\n    // Only enumerate devices if mediaDevices is available\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      console.warn('MediaDevices API not available');\n      return;\n    }\n\n    try {\n      console.log('Requesting device access and enumerating media devices...');\n\n      // Request microphone access first to get permissions\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          }\n        });\n        // Stop the stream immediately after getting permissions\n        stream.getTracks().forEach(track => track.stop());\n        console.log('Microphone access granted for device enumeration');\n      } catch (micError) {\n        console.warn('Could not get microphone access for device enumeration:', micError);\n        // Continue anyway - some devices might still be enumerable\n      }\n\n      // Now enumerate devices\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      console.log('Available devices:', devices);\n\n      this.inputDevices = devices\n        .filter(device => device.kind === 'audioinput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Microphone' : 'Unknown Microphone')\n        }));\n\n      this.outputDevices = devices\n        .filter(device => device.kind === 'audiooutput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Speaker' : 'Unknown Speaker')\n        }));\n\n      console.log('Input devices found:', this.inputDevices.length);\n      console.log('Output devices found:', this.outputDevices.length);\n\n      if (!this.selectedInputDeviceId && this.inputDevices.length > 0) {\n        this.selectedInputDeviceId = this.inputDevices[0].deviceId || 'default';\n      }\n      if (!this.selectedOutputDeviceId && this.outputDevices.length > 0) {\n        this.selectedOutputDeviceId = this.outputDevices[0].deviceId || 'default';\n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    } catch (error) {\n      console.error('Error enumerating devices:', error);\n\n      // If enumeration fails, try to get basic device info\n      if (error.name === 'NotAllowedError') {\n        // User denied permission, but we can still show default devices\n        this.inputDevices = [{\n          deviceId: 'default',\n          label: 'Default Microphone'\n        }];\n        this.outputDevices = [{\n          deviceId: 'default',\n          label: 'Default Speaker'\n        }];\n        console.log('Using default devices due to permission denial');\n      } else {\n        // For other errors, show placeholder devices\n        this.inputDevices = [{\n          deviceId: '',\n          label: 'No microphone detected'\n        }];\n        this.outputDevices = [{\n          deviceId: '',\n          label: 'No speaker detected'\n        }];\n        console.log('Using placeholder devices due to error');\n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    }\n  }\n\n  async setupWebRTC() {\n    if (!this.audioOutputElement) {\n      console.error(\"Audio output element not found\");\n      return;\n    }\n\n    try {\n      console.log(\"Requesting microphone permissions...\");\n      const constraints = {\n        audio: this.selectedInputDeviceId ? {\n          deviceId: { exact: this.selectedInputDeviceId },\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        } : {\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        },\n      };\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      console.log(\"Microphone access granted.\");\n\n      this.currentStream = stream;\n      this.peerConnection = new RTCPeerConnection(await this.getTurnCredentials());\n\n      // Add tracks to peer connection\n      stream.getTracks().forEach(track => {\n        console.log(`Adding track: ${track.kind}`);\n        this.peerConnection.addTrack(track, stream);\n      });\n\n      // Handle remote tracks\n      this.peerConnection.addEventListener(\"track\", (evt) => {\n        console.log(`Track received: ${evt.track.kind}`);\n        if (this.audioOutputElement.srcObject !== evt.streams[0]) {\n          console.log(\"Attaching remote stream to audio element\");\n          this.audioOutputElement.srcObject = evt.streams[0];\n\n          // Try to play and unmute the audio\n          this.audioOutputElement.play().then(() => {\n            // Unmute once we start receiving audio\n            if (this.audioOutputElement.muted) {\n              this.audioOutputElement.muted = false;\n              console.log(\"Audio unmuted for remote stream\");\n            }\n          }).catch(error => {\n            console.warn(\"Audio autoplay failed:\", error);\n            // Still unmute in case it helps\n            this.audioOutputElement.muted = false;\n          });\n        }\n      });\n\n      // Create data channel\n      this.dataChannel = this.peerConnection.createDataChannel(\"text\");\n      this.dataChannel.onopen = () => console.log(\"Data channel: open\");\n      this.dataChannel.onclose = () => console.log(\"Data channel: closed\");\n      this.dataChannel.onerror = (error) => console.error(\"Data channel error:\", error);\n      this.dataChannel.onmessage = (event) => {\n        console.log(\"Data channel message received:\", event.data);\n      };\n\n      // Create offer\n      console.log(\"Creating offer...\");\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      console.log(\"Local description (offer) set.\");\n\n      const randomId = Math.random().toString(36).substring(7);\n      const webrtcId = randomId;\n\n      // Handle ICE candidates\n      this.peerConnection.onicecandidate = ({ candidate }) => {\n        if (candidate) {\n          console.debug(\"Sending ICE candidate\", candidate);\n          fetch(`${this.apiUrl}/webrtc/offer`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n              candidate: candidate.toJSON(),\n              webrtc_id: webrtcId,\n              type: \"ice-candidate\",\n            })\n          });\n        }\n      };\n\n      this.peerConnection.oniceconnectionstatechange = () => {\n        console.log(`ICE connection state change: ${this.peerConnection.iceConnectionState}`);\n      };\n\n      this.peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state change: ${this.peerConnection.connectionState}`);\n          if (this.peerConnection.connectionState === 'connected') {\n            this.isWebRTCConnected = true;\n            this.updateUI();\n          } else if (this.peerConnection.connectionState === 'failed' ||\n                   this.peerConnection.connectionState === 'disconnected' ||\n                   this.peerConnection.connectionState === 'closed') {\n            this.isWebRTCConnected = false;\n            this.updateUI();\n          }\n      };\n\n      // Send offer to server\n      console.log(\"Sending offer to server...\");\n      const response = await fetch(`${this.apiUrl}/webrtc/offer`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          sdp: offer.sdp,\n          type: offer.type,\n          webrtc_id: webrtcId\n        })\n      });\n\n      console.log(\"Offer sent, server responded.\");\n      const serverResponse = await response.json();\n      console.log(\"Received answer data:\", serverResponse);\n\n      // Check if serverResponse is valid\n      if (!serverResponse || typeof serverResponse !== 'object') {\n        throw new Error('Invalid server response: not an object');\n      }\n\n      if (!serverResponse.sdp || !serverResponse.type) {\n        throw new Error('Invalid server response: missing sdp or type');\n      }\n\n      // Create proper RTCSessionDescription object\n      const answer = new RTCSessionDescription({\n        type: serverResponse.type,\n        sdp: serverResponse.sdp\n      });\n\n      await this.peerConnection.setRemoteDescription(answer);\n      console.log(\"Remote description (answer) set.\");\n\n    } catch (error) {\n      console.error(\"Error in WebRTC setup process:\", error);\n\n      // Provide more specific error messages\n      if (error.name === 'NotAllowedError') {\n        alert(\"Microphone access denied. Please allow microphone access in your browser settings.\");\n      } else if (error.name === 'NotFoundError') {\n        alert(\"No microphone found. Please connect a microphone and try again.\");\n      } else if (error.name === 'NotReadableError') {\n        alert(\"Microphone is in use by another application. Please close other apps using the microphone.\");\n      } else if (error.message.includes('Failed to parse SessionDescription')) {\n        alert(\"WebRTC connection failed: Invalid server response. Please check your WebRTC backend.\");\n        console.error(\"Server response was:\", serverResponse);\n      } else {\n        alert(\"WebRTC connection failed: \" + error.message);\n      }\n    }\n  }\n\n  async shutdownWebRTC() {\n    console.log(\"Shutting down WebRTC connection...\");\n\n    if (this.peerConnection) {\n      const senders = this.peerConnection.getSenders();\n      senders.forEach(sender => {\n        if (sender.track) {\n          console.log(`Stopping track: ${sender.track.kind}`);\n          sender.track.stop();\n        }\n      });\n\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.currentStream) {\n      this.currentStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.currentStream = null;\n    }\n\n    console.log(\"WebRTC connection closed and microphone access released.\");\n    this.isWebRTCConnected = false;\n    this.updateUI();\n  }\n\n  async handleToggleVoiceChat() {\n    if (this.isWebRTCConnected) {\n      await this.shutdownWebRTC();\n    } else {\n      if (this.isConnecting) {\n        console.log(\"Connection attempt already in progress.\");\n        return;\n      }\n\n      if (!this.peerConnection || this.peerConnection.signalingState === 'closed') {\n        console.log(\"Initializing or re-initializing RTCPeerConnection for a new session.\");\n        this.peerConnection = new RTCPeerConnection(await this.getTurnCredentials());\n      }\n\n      if (!this.peerConnection) {\n        console.error(\"RTCPeerConnection is null even after initialization attempt.\");\n        return;\n      }\n\n      this.isConnecting = true;\n      this.updateUI();\n      console.log(\"Attempting to start voice chat setup...\");\n\n      try {\n        await this.setupWebRTC();\n      } catch (error) {\n        console.error(\"Error during setupWebRTC:\", error);\n      } finally {\n        this.isConnecting = false;\n        this.updateUI();\n      }\n    }\n  }\n\n  async handleInputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid input device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.inputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected input device info:', selected || { deviceId, note: 'Not found in inputDevices' });\n\n    this.selectedInputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    // If we're connected, we need to replace the input track\n    if (this.isWebRTCConnected && this.peerConnection && this.currentStream) {\n      try {\n        console.log(`Switching input device to: ${deviceId}`);\n\n        // Get new stream with selected device\n        const constraints = {\n          audio: deviceId && deviceId !== 'default' ? {\n            deviceId: { exact: deviceId },\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          } : {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          },\n        };\n\n        const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n        console.log(\"New microphone stream obtained.\");\n\n        // Stop old tracks\n        this.currentStream.getTracks().forEach(track => {\n          track.stop();\n        });\n\n        // Replace tracks in peer connection\n        const sender = this.peerConnection.getSenders().find(s =>\n          s.track && s.track.kind === 'audio'\n        );\n\n        if (sender && newStream.getAudioTracks().length > 0) {\n          await sender.replaceTrack(newStream.getAudioTracks()[0]);\n          console.log(\"Audio track replaced successfully.\");\n        } else {\n          console.error(\"Could not find audio sender or new audio track.\");\n        }\n\n        // Update stream reference\n        this.currentStream = newStream;\n\n      } catch (error) {\n        console.error('Error changing input device during connection:', error);\n        // Try to revert the device selection if it failed\n        const originalDevice = this.selectedInputDeviceId;\n        this.selectedInputDeviceId = originalDevice;\n        this.updateDeviceMenus();\n      }\n    }\n  }\n\n  async handleOutputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid output device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.outputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected output device info:', selected || { deviceId, note: 'Not found in outputDevices' });\n\n    this.selectedOutputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    if (this.audioOutputElement && this.audioOutputElement.setSinkId) {\n      try {\n        // Only try to set sink ID if it's not the default device\n        if (deviceId !== 'default') {\n          await this.audioOutputElement.setSinkId(deviceId);\n          console.log(`Audio output device changed to: ${deviceId}`);\n        } else {\n          console.log('Using default audio output device');\n        }\n      } catch (error) {\n        console.error('Error setting audio output device:', error);\n      }\n    } else {\n      console.warn('Audio output device change not supported in this browser');\n    }\n  }\n\n  async handleMuteToggle() {\n    if (!this.isWebRTCConnected || !this.peerConnection || !this.currentStream) {\n      console.warn('Cannot toggle mute - not connected or no stream');\n      return;\n    }\n\n    try {\n      // Get all audio tracks from the current stream\n      const audioTracks = this.currentStream.getAudioTracks();\n\n      if (audioTracks.length === 0) {\n        console.warn('No audio tracks found in current stream');\n        return;\n      }\n\n      // Toggle mute state\n      this.isMicMuted = !this.isMicMuted;\n\n      // Enable/disable all audio tracks (this stops/starts sending audio)\n      audioTracks.forEach(track => {\n        track.enabled = !this.isMicMuted;\n      });\n\n      console.log(`Microphone ${this.isMicMuted ? 'muted' : 'unmuted'}`);\n\n      // Find the audio sender in the peer connection\n      const sender = this.peerConnection.getSenders().find(s =>\n        s.track && s.track.kind === 'audio'\n      );\n\n      if (sender) {\n        // Update the sender to reflect the mute state\n        // The track.enabled property change should be sufficient\n        // but we can also update the sender if needed\n        console.log('Audio sender found, mute state updated');\n      }\n\n      this.updateUI();\n    } catch (error) {\n      console.error('Error toggling mute:', error);\n      // Revert the state if there was an error\n      this.isMicMuted = !this.isMicMuted;\n      this.updateUI();\n    }\n  }\n\n  // UI functionality\n  render() {\n    const container = document.createElement('div');\n    container.className = 'widget-container';\n\n    const style = document.createElement('style');\n    style.textContent = `\n      .widget-container {\n        display: inline-flex;\n        align-items: center;\n        gap: 12px;\n        background: #ffffff;\n        border: 1px solid #e5e7eb;\n        border-radius: 24px;\n        padding: 8px 16px 8px 12px;\n        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n        font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        box-sizing: border-box;\n        position: relative;\n        transition: all 0.2s ease;\n        max-width: 320px;\n        min-width: 200px;\n      }\n\n      .widget-container:hover {\n        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n      }\n\n      .widget-buttons {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n      }\n\n      .mic-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 40px;\n        height: 40px;\n        border-radius: 50%;\n        background: #ffffff;\n        border: 2px solid #e5e7eb;\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n        flex-shrink: 0;\n      }\n\n      .mic-button.active {\n        background: #ef4444;\n        border-color: #dc2626;\n      }\n\n      .mic-button.connecting {\n        background: #f59e0b;\n        border-color: #d97706;\n      }\n\n      /* Call button (idle state) - plain/neutral */\n      .mic-button:not(.active):not(.connecting) {\n        background: #ffffff;\n        border-color: #e5e7eb;\n      }\n\n      .mic-button:hover {\n        transform: scale(1.05);\n      }\n\n      .mic-button:disabled {\n        opacity: 0.6;\n        cursor: not-allowed;\n        transform: none;\n      }\n\n      /* Mute button states - plain when not muted, yellow when muted */\n      .mic-button.muted {\n        background: #fbbf24;\n        border-color: #f59e0b;\n      }\n\n      .text-container {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        gap: 2px;\n        min-width: 0;\n      }\n\n      .primary-text {\n        font-size: 13px;\n        font-weight: 500;\n        color: #111827;\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .secondary-text {\n        font-size: 11px;\n        color: #6b7280;\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .menu-container {\n        position: absolute;\n        top: 50%;\n        right: 8px;\n        transform: translateY(-50%);\n        z-index: 10;\n      }\n\n      .settings-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 32px;\n        height: 32px;\n        border-radius: 50%;\n        background: #f3f4f6;\n        border: none;\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n      }\n\n      .settings-button:hover {\n        background: #e5e7eb;\n      }\n\n      .device-menu {\n        position: absolute;\n        top: calc(100% + 4px);\n        right: 0;\n        background: white;\n        border: 1px solid #e5e7eb;\n        border-radius: 8px;\n        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);\n        min-width: 200px;\n        z-index: 1000;\n        display: none;\n      }\n\n      .device-menu.open {\n        display: block;\n      }\n\n      .device-menu-section {\n        padding: 8px;\n      }\n\n      .device-menu-label {\n        font-size: 12px;\n        font-weight: 500;\n        color: #6b7280;\n        text-transform: uppercase;\n        letter-spacing: 0.05em;\n        padding: 0 8px 4px;\n      }\n\n      .device-option {\n        display: flex;\n        align-items: center;\n        padding: 8px;\n        cursor: pointer;\n        border-radius: 4px;\n        transition: background-color 0.15s ease;\n      }\n\n      .device-option:hover {\n        background-color: #f3f4f6;\n      }\n\n      .device-option.selected {\n        background-color: #eff6ff;\n        color: #2563eb;\n      }\n\n      .device-option input[type=\"radio\"] {\n        margin-right: 8px;\n      }\n\n      .device-option label {\n        flex: 1;\n        cursor: pointer;\n        font-size: 14px;\n      }\n\n      .audio-element {\n        position: absolute;\n        visibility: hidden;\n        width: 1px;\n        height: 1px;\n        pointer-events: none;\n        opacity: 0;\n      }\n\n      .audio-element[autoplay] {\n        /* Ensure autoplay works */\n      }\n\n      .hidden {\n        display: none !important;\n      }\n\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n\n      .connecting-animation {\n        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n      }\n\n      .sr-only {\n        position: absolute;\n        width: 1px;\n        height: 1px;\n        padding: 0;\n        margin: -1px;\n        overflow: hidden;\n        clip: rect(0, 0, 0, 0);\n        white-space: nowrap;\n        border: 0;\n      }\n    `;\n\n    // Create the main button\n    const micButton = document.createElement('button');\n    micButton.className = `mic-button ${this.isWebRTCConnected ? 'active' : ''} ${this.isConnecting ? 'connecting' : ''}`;\n    micButton.setAttribute('aria-label', this.isWebRTCConnected ? 'Stop voice chat' : 'Start voice chat');\n\n    if (this.isConnecting) {\n      micButton.classList.add('connecting-animation');\n    }\n\n    // Add screen reader text\n    const srText = document.createElement('span');\n    srText.className = 'sr-only';\n    srText.textContent = this.isWebRTCConnected ? 'Stop Voice Chat' : 'Start Voice Chat';\n\n    // Add icons based on state (Lucide-style SVGs)\n    const callIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-icon lucide-phone\"><path d=\"M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384\"/></svg>'\n      \n    micButton.innerHTML = callIcon;\n    micButton.appendChild(srText);\n\n    // Create text container\n    const textContainer = document.createElement('div');\n    textContainer.className = 'text-container';\n\n    const primaryText = document.createElement('p');\n    primaryText.className = 'primary-text';\n    primaryText.textContent = this.isConnecting ? 'Connecting...' : this.isWebRTCConnected ? 'Connected' : 'Click to start!';\n\n    const secondaryText = document.createElement('p');\n    secondaryText.className = 'secondary-text';\n    secondaryText.textContent = 'Click to disconnect';\n    if (!this.isWebRTCConnected) {\n      secondaryText.style.display = 'none';\n    }\n\n    textContainer.appendChild(primaryText);\n    textContainer.appendChild(secondaryText);\n\n    // Create device menu if needed\n    let menuContainer = null;\n    if (this.showDeviceSelection) {\n      menuContainer = document.createElement('div');\n      menuContainer.className = 'menu-container';\n\n      const settingsButton = document.createElement('button');\n      settingsButton.className = 'settings-button';\n      settingsButton.setAttribute('aria-label', 'Device settings');\n      settingsButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-settings-icon lucide-settings\"><path d=\"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915\"/><circle cx=\"12\" cy=\"12\" r=\"3\"/></svg>';\n\n      const deviceMenu = document.createElement('div');\n      deviceMenu.className = 'device-menu';\n      this.buildDeviceMenuContent(deviceMenu);\n\n      settingsButton.addEventListener('click', async (e) => {\n        e.stopPropagation();\n\n        // If devices haven't been enumerated yet, do it now\n        if (this.inputDevices.length === 0 && this.outputDevices.length === 0) {\n          console.log('Settings button clicked - enumerating devices...');\n          await this.enumerateDevices();\n        }\n\n        deviceMenu.classList.toggle('open');\n      });\n\n      // Close menu when clicking outside\n      document.addEventListener('click', (e) => {\n        if (!menuContainer.contains(e.target)) {\n          deviceMenu.classList.remove('open');\n        }\n      });\n\n      menuContainer.appendChild(settingsButton);\n      menuContainer.appendChild(deviceMenu);\n    }\n\n    // Create expanded state buttons if connected\n    if (this.isWebRTCConnected) {\n      const buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'widget-buttons';\n\n      // Hang up button (red)\n      const hangUpButton = document.createElement('button');\n      hangUpButton.className = 'mic-button active';\n      hangUpButton.setAttribute('aria-label', 'Hang up');\n      hangUpButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-off-icon lucide-phone-off\"><path d=\"M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272\"/><path d=\"M22 2 2 22\"/><path d=\"M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473\"/></svg>'\n\n      // Mute button\n      const muteButton = document.createElement('button');\n      muteButton.className = `mic-button ${this.isMicMuted ? 'muted' : ''}`;\n      muteButton.setAttribute('aria-label', this.isMicMuted ? 'Unmute microphone' : 'Mute microphone');\n      muteButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-off-icon lucide-mic-off\"><path d=\"M12 19v3\"/><path d=\"M15 9.34V5a3 3 0 0 0-5.68-1.33\"/><path d=\"M16.95 16.95A7 7 0 0 1 5 12v-2\"/><path d=\"M18.89 13.23A7 7 0 0 0 19 12v-2\"/><path d=\"m2 2 20 20\"/><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12\"/></svg>'\n      buttonsContainer.appendChild(hangUpButton);\n      buttonsContainer.appendChild(muteButton);\n      container.appendChild(buttonsContainer);\n    } else {\n      container.appendChild(micButton);\n    }\n\n    container.appendChild(textContainer);\n\n    if (menuContainer) {\n      // Position the menu container absolutely over the button area\n      container.style.position = 'relative';\n      container.appendChild(menuContainer);\n    }\n\n    // Hidden audio element with autoplay for remote stream\n    this.audioOutputElement = document.createElement('audio');\n    this.audioOutputElement.className = 'audio-element';\n    this.audioOutputElement.id = 'fastrtc-voice-widget-audio';\n    this.audioOutputElement.autoplay = true;\n    this.audioOutputElement.playsInline = true;\n    this.audioOutputElement.controls = false;\n    this.audioOutputElement.muted = false; // Start muted to avoid autoplay issues\n    container.appendChild(this.audioOutputElement);\n\n    this.shadowRoot.innerHTML = '';\n    this.shadowRoot.appendChild(style);\n    this.shadowRoot.appendChild(container);\n  }\n\n  updateUI() {\n    this.render();\n    this.setupEventListeners();\n  }\n\n  updateDeviceMenus() {\n    // This would update the radio button states in the device menu\n    const deviceMenu = this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      const inputRadios = deviceMenu.querySelectorAll('input[name=\"input-device\"]');\n      const outputRadios = deviceMenu.querySelectorAll('input[name=\"output-device\"]');\n\n      inputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedInputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n\n      outputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedOutputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n    }\n  }\n\n  buildDeviceMenuContent(deviceMenu) {\n    if (!deviceMenu) return;\n\n    // Clear existing content\n    deviceMenu.innerHTML = '';\n\n    // Input devices section\n    const inputSection = document.createElement('div');\n    inputSection.className = 'device-menu-section';\n\n    const inputLabel = document.createElement('div');\n    inputLabel.className = 'device-menu-label';\n    inputLabel.textContent = 'Input Device';\n    inputSection.appendChild(inputLabel);\n\n    this.inputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedInputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'input-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedInputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleInputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      inputSection.appendChild(option);\n    });\n\n    // Output devices section\n    const outputSection = document.createElement('div');\n    outputSection.className = 'device-menu-section';\n\n    const outputLabel = document.createElement('div');\n    outputLabel.className = 'device-menu-label';\n    outputLabel.textContent = 'Output Device';\n    outputSection.appendChild(outputLabel);\n\n    this.outputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedOutputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'output-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedOutputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleOutputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      outputSection.appendChild(option);\n    });\n\n    deviceMenu.appendChild(inputSection);\n    deviceMenu.appendChild(outputSection);\n  }\n\n  rebuildDeviceMenu() {\n    const deviceMenu = this.shadowRoot && this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      this.buildDeviceMenuContent(deviceMenu);\n    }\n  }\n\n  setupEventListeners() {\n    // Main mic button (for start/stop)\n    const micButton = this.shadowRoot.querySelector('.mic-button:not(.active)');\n    if (micButton) {\n      micButton.addEventListener('click', () => this.handleToggleVoiceChat());\n    }\n\n    // Hang up button (red)\n    const hangUpButton = this.shadowRoot.querySelector('.mic-button.active');\n    if (hangUpButton && !hangUpButton.hasEventListener) {\n      hangUpButton.addEventListener('click', () => this.handleToggleVoiceChat());\n      hangUpButton.hasEventListener = true;\n    }\n\n    // Mute button (toggle)\n    const muteButton = this.shadowRoot.querySelector('.widget-buttons .mic-button:not(.active)');\n    if (muteButton && !muteButton.hasEventListener) {\n      muteButton.addEventListener('click', () => {\n        this.handleMuteToggle();\n      });\n      muteButton.hasEventListener = true;\n    }\n  }\n\n  cleanup() {\n    this.shutdownWebRTC();\n\n    if (this.audioOutputElement) {\n      this.audioOutputElement.srcObject = null;\n    }\n  }\n}\n\n// Register the web component\nif (!customElements.get('fast-rtc-voice-widget')) {\n  customElements.define('fast-rtc-voice-widget', FastRTCVoiceWidget);\n}\n\n// Handle case where elements are already in DOM before script loads\nif (document.readyState === 'loading') {\n  // Document is still loading, wait for DOMContentLoaded\n  document.addEventListener('DOMContentLoaded', () => {\n    initializeExistingWidgets();\n  });\n} else {\n  // Document already loaded, initialize immediately\n  initializeExistingWidgets();\n}\n\nfunction initializeExistingWidgets() {\n  // Find all existing fast-rtc-voice-widget elements and upgrade them\n  const widgets = document.querySelectorAll('fast-rtc-voice-widget');\n  widgets.forEach(widget => {\n    if (!widget.shadowRoot) {\n      // Element hasn't been upgraded yet, manually trigger connectedCallback\n      const instance = new FastRTCVoiceWidget();\n      Object.setPrototypeOf(widget, instance);\n      instance.connectedCallback();\n    }\n  });\n}\n\n// Export for use in other contexts\nwindow.FastRTCVoiceWidget = FastRTCVoiceWidget;\n"],"names":["FastRTCVoiceWidget","HTMLElement","constructor","super","this","attachShadow","mode","isWebRTCConnected","isConnecting","peerConnection","currentStream","dataChannel","audioOutputElement","inputDevices","outputDevices","selectedInputDeviceId","selectedOutputDeviceId","isExpanded","isMicMuted","connectedCallback","apiUrl","getAttribute","authToken","showDeviceSelection","hasAttribute","render","setupEventListeners","error","console","disconnectedCallback","cleanup","getTurnCredentials","response","fetch","headers","ok","Error","status","json","iceServers","urls","enumerateDevices","navigator","mediaDevices","log","getUserMedia","audio","noiseSuppression","echoCancellation","autoGainControl","getTracks","forEach","track","stop","micError","warn","devices","filter","device","kind","map","deviceId","label","trim","length","rebuildDeviceMenu","updateDeviceMenus","name","setupWebRTC","constraints","exact","stream","RTCPeerConnection","addTrack","addEventListener","evt","srcObject","streams","play","then","muted","catch","createDataChannel","onopen","onclose","onerror","onmessage","event","data","offer","createOffer","setLocalDescription","webrtcId","Math","random","toString","substring","onicecandidate","candidate","debug","method","body","JSON","stringify","toJSON","webrtc_id","type","oniceconnectionstatechange","iceConnectionState","onconnectionstatechange","connectionState","updateUI","sdp","serverResponse","answer","RTCSessionDescription","setRemoteDescription","alert","message","includes","shutdownWebRTC","getSenders","sender","close","handleToggleVoiceChat","signalingState","handleInputDeviceChange","selected","find","d","note","newStream","s","getAudioTracks","replaceTrack","originalDevice","handleOutputDeviceChange","setSinkId","handleMuteToggle","audioTracks","enabled","container","document","createElement","className","style","textContent","micButton","setAttribute","classList","add","srText","innerHTML","appendChild","textContainer","primaryText","secondaryText","display","menuContainer","settingsButton","deviceMenu","buildDeviceMenuContent","async","e","stopPropagation","toggle","contains","target","remove","buttonsContainer","hangUpButton","muteButton","position","id","autoplay","playsInline","controls","shadowRoot","querySelector","inputRadios","querySelectorAll","outputRadios","radio","checked","value","closest","inputSection","inputLabel","option","outputSection","outputLabel","hasEventListener","initializeExistingWidgets","widget","instance","Object","setPrototypeOf","customElements","get","define","readyState","window"],"mappings":"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"}
{"version":3,"file":"fastrtc-voice-widget.umd.js","sources":["../src/widget.js"],"sourcesContent":["// FastRTC Voice Widget - Language-agnostic embeddable widget\nclass FastRTCVoiceWidget extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.isWebRTCConnected = false;\n    this.isConnecting = false;\n    this.peerConnection = null;\n    this.currentStream = null;\n    this.dataChannel = null;\n    this.audioOutputElement = null;\n    this.shadowClickListenerAdded = false;\n    this.playbackStarted = false;\n    this.debugEnabled = false;\n\n    // Device state\n    this.inputDevices = [];\n    this.outputDevices = [];\n    this.selectedInputDeviceId = '';\n    this.selectedOutputDeviceId = '';\n\n    // UI state\n    this.isExpanded = false;\n    this.isMicMuted = false;\n  }\n\n  static get observedAttributes() {\n    return ['debug'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'debug') {\n      this.debugEnabled = this.hasAttribute('debug');\n    }\n  }\n\n  debugLog(...args) {\n    if (this.debugEnabled) {\n      console.log(...args);\n    }\n  }\n\n  connectedCallback() {\n    try {\n      this.apiUrl = this.getAttribute('api-url') || '';\n      this.authToken = this.getAttribute('auth-token') || '';\n      this.showDeviceSelection = this.hasAttribute('show-device-selection');\n      this.debugEnabled = this.hasAttribute('debug');\n\n    // Check for demo attributes\n    if (this.hasAttribute('is-connected')) {\n      this.isWebRTCConnected = true;\n    }\n\n      this.render();\n      this.setupEventListeners();\n      // Device enumeration now happens only when settings button is clicked\n    } catch (error) {\n      console.error('Error in connectedCallback:', error);\n    }\n  }\n\n  disconnectedCallback() {\n    this.cleanup();\n  }\n\n  // WebRTC functionality\n  async getTurnCredentials() {\n    try {\n      const response = await fetch(`${this.apiUrl}/webrtc/turn-credentials`, {\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get TURN credentials: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching TURN credentials:', error);\n      return {\n        iceServers: [\n          { urls: 'stun:stun.l.google.com:19302' }\n        ]\n      };\n    }\n  }\n\n  async enumerateDevices() {\n    // Only enumerate devices if mediaDevices is available\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      console.warn('MediaDevices API not available');\n      return;\n    }\n\n    try {\n\n      // Request microphone access first to get permissions\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          }\n        });\n        // Stop the stream immediately after getting permissions\n        stream.getTracks().forEach(track => track.stop());\n        console.log('Microphone access granted for device enumeration');\n      } catch (micError) {\n        // Continue anyway - some devices might still be enumerable\n      }\n\n      // Now enumerate devices\n      const devices = await navigator.mediaDevices.enumerateDevices();\n\n      this.inputDevices = devices\n        .filter(device => device.kind === 'audioinput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Microphone' : 'Unknown Microphone')\n        }));\n\n      this.outputDevices = devices\n        .filter(device => device.kind === 'audiooutput')\n        .map((device) => ({\n          deviceId: device.deviceId,\n          label: (device.label && device.label.trim())\n            ? device.label.trim()\n            : (device.deviceId === 'default' ? 'Default Speaker' : 'Unknown Speaker')\n        }));\n\n      \n\n      if (!this.selectedInputDeviceId && this.inputDevices.length > 0) {\n        this.selectedInputDeviceId = this.inputDevices[0].deviceId || 'default';\n      }\n      if (!this.selectedOutputDeviceId && this.outputDevices.length > 0) {\n        this.selectedOutputDeviceId = this.outputDevices[0].deviceId || 'default';\n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    } catch (error) {\n      console.error('Error enumerating devices:', error);\n\n      // If enumeration fails, try to get basic device info\n      if (error.name === 'NotAllowedError') {\n        // User denied permission, but we can still show default devices\n        this.inputDevices = [{\n          deviceId: 'default',\n          label: 'Default Microphone'\n        }];\n        this.outputDevices = [{\n          deviceId: 'default',\n          label: 'Default Speaker'\n        }];\n        \n      } else {\n        // For other errors, show placeholder devices\n        this.inputDevices = [{\n          deviceId: '',\n          label: 'No microphone detected'\n        }];\n        this.outputDevices = [{\n          deviceId: '',\n          label: 'No speaker detected'\n        }];\n        \n      }\n\n      this.rebuildDeviceMenu();\n      this.updateDeviceMenus();\n    }\n  }\n\n  async setupWebRTC() {\n    if (!this.audioOutputElement) {\n      console.error(\"Audio output element not found\");\n      return;\n    }\n\n    try {\n      const constraints = {\n        audio: this.selectedInputDeviceId ? {\n          deviceId: { exact: this.selectedInputDeviceId },\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        } : {\n          noiseSuppression: true,\n          echoCancellation: true,\n          autoGainControl: true\n        },\n      };\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      \n\n      this.currentStream = stream;\n      this.peerConnection = new RTCPeerConnection(await this.getTurnCredentials());\n\n      // Add tracks to peer connection\n      stream.getTracks().forEach(track => {\n        this.peerConnection.addTrack(track, stream);\n      });\n\n      // Handle remote tracks\n      this.peerConnection.addEventListener(\"track\", (evt) => {\n\n        if (evt.track.kind === 'audio') {\n          if (this.audioOutputElement) {\n            if (this.audioOutputElement.srcObject !== evt.streams[0]) {\n              // New remote stream attached; reset playback flag so we re-trigger play()\n              this.playbackStarted = false;\n              this.audioOutputElement.srcObject = evt.streams[0];\n\n              // Set volume and unmute\n              this.audioOutputElement.volume = 1.0;\n              this.audioOutputElement.muted = false;\n              // Defer to unified playback handler to avoid multiple play() calls\n              this.ensurePlayback();\n            } else {\n              \n            }\n          } else {\n            console.error(\"❌ Audio element not found!\");\n          }\n        } else {\n          \n        }\n      });\n\n      // Create data channel\n      this.dataChannel = this.peerConnection.createDataChannel(\"text\");\n      this.dataChannel.onopen = () => {\n        // If data channel opens and we're not marked as connected, force connection state\n        if (!this.isWebRTCConnected) {\n          this.isWebRTCConnected = true;\n          this.isConnecting = false;\n          this.updateUI();\n\n          // Force unmute audio element when data channel opens\n          this.forceUnmuteAudio();\n        }\n      };\n      this.dataChannel.onclose = () => {};\n      this.dataChannel.onerror = (error) => console.error(\"Data channel error:\", error);\n      this.dataChannel.onmessage = (event) => {\n        // If we receive data channel messages and we're not marked as connected, force connection state\n        if (!this.isWebRTCConnected) {\n          this.isWebRTCConnected = true;\n          this.updateUI();\n\n          // Force unmute audio element when data channel messages arrive\n          this.forceUnmuteAudio();\n        }\n      };\n\n      // Create offer\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n\n      const randomId = Math.random().toString(36).substring(7);\n      const webrtcId = randomId;\n\n      // Handle ICE candidates\n      this.peerConnection.onicecandidate = ({ candidate }) => {\n        if (candidate) {\n          fetch(`${this.apiUrl}/webrtc/offer`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n              candidate: candidate.toJSON(),\n              webrtc_id: webrtcId,\n              type: \"ice-candidate\",\n            })\n          });\n        }\n      };\n\n      this.peerConnection.oniceconnectionstatechange = () => {\n\n        // If ICE is connected and we have data channel messages, consider it connected\n        if (this.peerConnection.iceConnectionState === 'connected' ||\n            this.peerConnection.iceConnectionState === 'completed') {\n          if (!this.isWebRTCConnected) {\n            this.isWebRTCConnected = true;\n            this.isConnecting = false;\n            this.updateUI();\n\n            // Force unmute audio element when ICE connected\n            this.forceUnmuteAudio();\n          }\n        } else if (this.peerConnection.iceConnectionState === 'failed' ||\n                   this.peerConnection.iceConnectionState === 'disconnected') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        }\n      };\n\n      this.peerConnection.onconnectionstatechange = () => {\n\n        if (this.peerConnection.connectionState === 'connected') {\n          this.isWebRTCConnected = true;\n          this.isConnecting = false;\n          this.updateUI();\n\n          // Force unmute audio element when connected\n          this.forceUnmuteAudio();\n        } else if (this.peerConnection.connectionState === 'connecting') {\n          \n        } else if (this.peerConnection.connectionState === 'new') {\n          \n        } else if (this.peerConnection.connectionState === 'failed') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        } else if (this.peerConnection.connectionState === 'disconnected' ||\n                   this.peerConnection.connectionState === 'closed') {\n          this.isWebRTCConnected = false;\n          this.isConnecting = false;\n          this.updateUI();\n        }\n      };\n\n      // Send offer to server\n      const response = await fetch(`${this.apiUrl}/webrtc/offer`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          sdp: offer.sdp,\n          type: offer.type,\n          webrtc_id: webrtcId\n        })\n      });\n\n      let serverResponse;\n      try {\n        serverResponse = await response.json();\n\n        // Validate server response\n        if (!serverResponse || typeof serverResponse !== 'object') {\n          throw new Error('Invalid server response: not an object');\n        }\n\n        if (!serverResponse.sdp || !serverResponse.type) {\n          throw new Error('Invalid server response: missing sdp or type');\n        }\n\n        // Create proper RTCSessionDescription object\n        const answer = new RTCSessionDescription({\n          type: serverResponse.type,\n          sdp: serverResponse.sdp\n        });\n\n        await this.peerConnection.setRemoteDescription(answer);\n\n      } catch (parseError) {\n        // Handle JSON parsing errors or validation errors\n        console.error(\"Error parsing server response:\", parseError);\n        console.error(\"Server response was:\", serverResponse);\n        throw new Error(`Failed to parse server response: ${parseError.message}`);\n      }\n\n    } catch (error) {\n      console.error(\"Error in WebRTC setup process:\", error);\n\n      // Provide more specific error messages\n      if (error.name === 'NotAllowedError') {\n        alert(\"Microphone access denied. Please allow microphone access in your browser settings.\");\n      } else if (error.name === 'NotFoundError') {\n        alert(\"No microphone found. Please connect a microphone and try again.\");\n      } else if (error.name === 'NotReadableError') {\n        alert(\"Microphone is in use by another application. Please close other apps using the microphone.\");\n      } else if (error.message.includes('Failed to parse SessionDescription')) {\n        alert(\"WebRTC connection failed: Invalid server response. Please check your WebRTC backend.\");\n        console.error(\"Server response was:\", serverResponse);\n      } else {\n        alert(\"WebRTC connection failed: \" + error.message);\n      }\n\n      // Clean up on error\n      this.isWebRTCConnected = false;\n      this.updateUI();\n    }\n  }\n\n  async shutdownWebRTC() {\n    console.log(\"Shutting down WebRTC connection...\");\n\n    if (this.peerConnection) {\n      const senders = this.peerConnection.getSenders();\n      senders.forEach(sender => {\n        if (sender.track) {\n          console.log(`Stopping track: ${sender.track.kind}`);\n          sender.track.stop();\n        }\n      });\n\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.currentStream) {\n      this.currentStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.currentStream = null;\n    }\n\n    console.log(\"WebRTC connection closed and microphone access released.\");\n    this.isWebRTCConnected = false;\n    this.updateUI();\n  }\n\n  async handleToggleVoiceChat() {\n    if (this.isWebRTCConnected) {\n      await this.shutdownWebRTC();\n    } else {\n      if (this.isConnecting) {\n        console.log(\"Connection attempt already in progress.\");\n        return;\n      }\n\n      // RTCPeerConnection will be created inside setupWebRTC()\n\n      this.isConnecting = true;\n      this.updateUI();\n      console.log(\"Attempting to start voice chat setup...\");\n\n      try {\n        await this.setupWebRTC();\n        // Don't reset isConnecting here - let the event handlers in setupWebRTC() handle state transitions\n        // The connection state will be managed by the ICE/connection state change handlers\n      } catch (error) {\n        console.error(\"Error during setupWebRTC:\", error);\n        // Only reset connecting state on actual error\n        this.isConnecting = false;\n        this.updateUI();\n      }\n      // Note: If setupWebRTC() succeeds, the event handlers will set isWebRTCConnected = true\n      // and isConnecting = false, which will trigger UI updates automatically\n    }\n  }\n\n  async handleInputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid input device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.inputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected input device info:', selected || { deviceId, note: 'Not found in inputDevices' });\n\n    this.selectedInputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    // If we're connected, we need to replace the input track\n    if (this.isWebRTCConnected && this.peerConnection && this.currentStream) {\n      try {\n        console.log(`Switching input device to: ${deviceId}`);\n\n        // Get new stream with selected device\n        const constraints = {\n          audio: deviceId && deviceId !== 'default' ? {\n            deviceId: { exact: deviceId },\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          } : {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n          },\n        };\n\n        const newStream = await navigator.mediaDevices.getUserMedia(constraints);\n        console.log(\"New microphone stream obtained.\");\n\n        // Stop old tracks\n        this.currentStream.getTracks().forEach(track => {\n          track.stop();\n        });\n\n        // Replace tracks in peer connection\n        const sender = this.peerConnection.getSenders().find(s =>\n          s.track && s.track.kind === 'audio'\n        );\n\n        if (sender && newStream.getAudioTracks().length > 0) {\n          await sender.replaceTrack(newStream.getAudioTracks()[0]);\n          console.log(\"Audio track replaced successfully.\");\n        } else {\n          console.error(\"Could not find audio sender or new audio track.\");\n        }\n\n        // Update stream reference\n        this.currentStream = newStream;\n\n      } catch (error) {\n        console.error('Error changing input device during connection:', error);\n        // Try to revert the device selection if it failed\n        const originalDevice = this.selectedInputDeviceId;\n        this.selectedInputDeviceId = originalDevice;\n        this.updateDeviceMenus();\n      }\n    }\n  }\n\n  async handleOutputDeviceChange(deviceId) {\n    // Only proceed if deviceId is valid\n    if (!deviceId || deviceId === '') {\n      console.warn('Invalid output device ID:', deviceId);\n      return;\n    }\n\n    const selected = this.outputDevices.find(d => (d.deviceId || 'default') === deviceId);\n    console.log('Selected output device info:', selected || { deviceId, note: 'Not found in outputDevices' });\n\n    this.selectedOutputDeviceId = deviceId;\n    this.updateDeviceMenus();\n\n    if (this.audioOutputElement && this.audioOutputElement.setSinkId) {\n      try {\n        // Only try to set sink ID if it's not the default device\n        if (deviceId !== 'default') {\n          await this.audioOutputElement.setSinkId(deviceId);\n          console.log(`Audio output device changed to: ${deviceId}`);\n        } else {\n          console.log('Using default audio output device');\n        }\n      } catch (error) {\n        console.error('Error setting audio output device:', error);\n      }\n    } else {\n      console.warn('Audio output device change not supported in this browser');\n    }\n  }\n\n  async handleMuteToggle() {\n    if (!this.isWebRTCConnected || !this.peerConnection || !this.currentStream) {\n      console.warn('Cannot toggle mute - not connected or no stream');\n      return;\n    }\n\n    try {\n      // Get all audio tracks from the current stream\n      const audioTracks = this.currentStream.getAudioTracks();\n\n      if (audioTracks.length === 0) {\n        console.warn('No audio tracks found in current stream');\n        return;\n      }\n\n      // Toggle mute state\n      this.isMicMuted = !this.isMicMuted;\n\n      // Enable/disable all audio tracks (this stops/starts sending audio)\n      audioTracks.forEach(track => {\n        track.enabled = !this.isMicMuted;\n      });\n\n      console.log(`Microphone ${this.isMicMuted ? 'muted' : 'unmuted'}`);\n\n      // Find the audio sender in the peer connection\n      const sender = this.peerConnection.getSenders().find(s =>\n        s.track && s.track.kind === 'audio'\n      );\n\n      if (sender) {\n        // Update the sender to reflect the mute state\n        // The track.enabled property change should be sufficient\n        // but we can also update the sender if needed\n        console.log('Audio sender found, mute state updated');\n      }\n\n      this.updateUI();\n    } catch (error) {\n      console.error('Error toggling mute:', error);\n      // Revert the state if there was an error\n      this.isMicMuted = !this.isMicMuted;\n      this.updateUI();\n    }\n  }\n\n  // UI functionality\n  render() {\n    const container = document.createElement('div');\n    container.className = 'widget-container';\n\n    const style = document.createElement('style');\n    style.textContent = `\n      .widget-container {\n        display: inline-flex;\n        align-items: center;\n        gap: 12px;\n        background: #ffffff;\n        border: 1px solid #e5e7eb;\n        border-radius: 24px;\n        padding: 8px 16px 8px 12px;\n        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n        font-family: system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        box-sizing: border-box;\n        position: relative;\n        transition: all 0.2s ease;\n        max-width: 320px;\n        min-width: 200px;\n      }\n\n      .widget-container:hover {\n        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n      }\n\n      .widget-buttons {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n      }\n\n      .mic-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 40px;\n        height: 40px;\n        border-radius: 50%;\n        background: #ffffff;\n        border: 2px solid #e5e7eb;\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n        flex-shrink: 0;\n      }\n\n      .mic-button.active {\n        background: #ef4444;\n        border-color: #dc2626;\n        color: #ffffff;\n      }\n\n      .mic-button.connecting {\n        background: #f59e0b;\n        border-color: #d97706;\n        color: #ffffff;\n      }\n\n      /* Call button (idle state) - plain/neutral */\n      .mic-button:not(.active):not(.connecting) {\n        background: #ffffff;\n        border-color: #e5e7eb;\n      }\n\n      .mic-button:hover {\n        transform: scale(1.05);\n      }\n\n      .mic-button:disabled {\n        opacity: 0.6;\n        cursor: not-allowed;\n        transform: none;\n      }\n\n      /* Mute button states - plain when not muted, yellow when muted */\n      .mic-button.muted {\n        background: #fbbf24;\n        border-color: #f59e0b;\n        color: #111827 !important;\n      }\n      .mic-button.muted svg, .mic-button.muted svg * {\n        stroke: #111827 !important;\n      }\n\n      .text-container {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        gap: 2px;\n        min-width: 0;\n      }\n\n      .primary-text {\n        font-size: 13px;\n        font-weight: 500;\n        color: #111827;\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .secondary-text {\n        font-size: 11px;\n        color: #6b7280;\n        margin: 0;\n        line-height: 1.2;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      .menu-container {\n        position: absolute;\n        top: 50%;\n        right: 8px;\n        transform: translateY(-50%);\n        z-index: 10;\n      }\n\n      .settings-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 32px;\n        height: 32px;\n        border-radius: 50%;\n        background: #f3f4f6;\n        border: none;\n        cursor: pointer;\n        transition: all 0.2s ease;\n        outline: none;\n      }\n\n      .settings-button:hover {\n        background: #e5e7eb;\n      }\n\n      .device-menu {\n        position: absolute;\n        top: calc(100% + 4px);\n        right: 0;\n        background: white;\n        border: 1px solid #e5e7eb;\n        border-radius: 8px;\n        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);\n        min-width: 200px;\n        z-index: 1000;\n        display: none;\n      }\n\n      .device-menu.open {\n        display: block;\n      }\n\n      .device-menu-section {\n        padding: 8px;\n      }\n\n      .device-menu-label {\n        font-size: 12px;\n        font-weight: 500;\n        color: #6b7280;\n        text-transform: uppercase;\n        letter-spacing: 0.05em;\n        padding: 0 8px 4px;\n      }\n\n      .device-option {\n        display: flex;\n        align-items: center;\n        padding: 8px;\n        cursor: pointer;\n        border-radius: 4px;\n        transition: background-color 0.15s ease;\n      }\n\n      .device-option:hover {\n        background-color: #f3f4f6;\n      }\n\n      .device-option.selected {\n        background-color: #eff6ff;\n        color: #2563eb;\n      }\n\n      .device-option input[type=\"radio\"] {\n        margin-right: 8px;\n      }\n\n      .device-option label {\n        flex: 1;\n        cursor: pointer;\n        font-size: 14px;\n      }\n\n      .audio-element {\n        position: absolute;\n        visibility: hidden;\n        width: 1px;\n        height: 1px;\n        pointer-events: none;\n        opacity: 0;\n      }\n\n      .audio-element[autoplay] {\n        /* Ensure autoplay works */\n      }\n\n      .hidden {\n        display: none !important;\n      }\n\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n\n      .connecting-animation {\n        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n      }\n\n      .sr-only {\n        position: absolute;\n        width: 1px;\n        height: 1px;\n        padding: 0;\n        margin: -1px;\n        overflow: hidden;\n        clip: rect(0, 0, 0, 0);\n        white-space: nowrap;\n        border: 0;\n      }\n    `;\n\n    // Create the main button\n    const micButton = document.createElement('button');\n    micButton.className = `mic-button ${this.isWebRTCConnected ? 'active' : ''} ${this.isConnecting ? 'connecting' : ''}`;\n    micButton.setAttribute('aria-label', this.isWebRTCConnected ? 'Stop voice chat' : 'Start voice chat');\n    micButton.setAttribute('data-role', 'call');\n\n    if (this.isConnecting && !this.isWebRTCConnected) {\n      micButton.classList.add('connecting-animation');\n    }\n\n    // Add screen reader text\n    const srText = document.createElement('span');\n    srText.className = 'sr-only';\n    srText.textContent = this.isWebRTCConnected ? 'Stop Voice Chat' : 'Start Voice Chat';\n\n    // Add icons based on state (Lucide-style SVGs)\n    const callIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-icon lucide-phone\"><path d=\"M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384\"/></svg>'\n      \n    micButton.innerHTML = callIcon;\n    micButton.appendChild(srText);\n\n    // Create text container\n    const textContainer = document.createElement('div');\n    textContainer.className = 'text-container';\n\n    const primaryText = document.createElement('p');\n    primaryText.className = 'primary-text';\n    primaryText.textContent = (this.isConnecting && !this.isWebRTCConnected) ? 'Connecting...' : this.isWebRTCConnected ? 'Connected' : 'Click to start!';\n\n    const secondaryText = document.createElement('p');\n    secondaryText.className = 'secondary-text';\n    secondaryText.textContent = 'Click to disconnect';\n    if (!this.isWebRTCConnected) {\n      secondaryText.style.display = 'none';\n    }\n\n    textContainer.appendChild(primaryText);\n    textContainer.appendChild(secondaryText);\n\n    // Create device menu if needed\n    let menuContainer = null;\n    if (this.showDeviceSelection) {\n      menuContainer = document.createElement('div');\n      menuContainer.className = 'menu-container';\n\n      const settingsButton = document.createElement('button');\n      settingsButton.className = 'settings-button';\n      settingsButton.setAttribute('aria-label', 'Device settings');\n      settingsButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-settings-icon lucide-settings\"><path d=\"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915\"/><circle cx=\"12\" cy=\"12\" r=\"3\"/></svg>';\n\n      const deviceMenu = document.createElement('div');\n      deviceMenu.className = 'device-menu';\n      this.buildDeviceMenuContent(deviceMenu);\n\n      settingsButton.addEventListener('click', async (e) => {\n        e.stopPropagation();\n\n        // If devices haven't been enumerated yet, do it now\n        if (this.inputDevices.length === 0 && this.outputDevices.length === 0) {\n          console.log('Settings button clicked - enumerating devices...');\n          await this.enumerateDevices();\n        }\n\n        deviceMenu.classList.toggle('open');\n      });\n\n      // Close menu when clicking outside\n      document.addEventListener('click', (e) => {\n        if (!menuContainer.contains(e.target)) {\n          deviceMenu.classList.remove('open');\n        }\n      });\n\n      menuContainer.appendChild(settingsButton);\n      menuContainer.appendChild(deviceMenu);\n    }\n\n    // Create expanded state buttons if connected\n    if (this.isWebRTCConnected) {\n      const buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'widget-buttons';\n\n      // Hang up button (red)\n      const hangUpButton = document.createElement('button');\n      hangUpButton.className = 'mic-button active';\n      hangUpButton.setAttribute('aria-label', 'Hang up');\n      hangUpButton.setAttribute('data-role', 'hangup');\n      hangUpButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-phone-off-icon lucide-phone-off\"><path d=\"M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272\"/><path d=\"M22 2 2 22\"/><path d=\"M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473\"/></svg>'\n\n      // Mute button\n      const muteButton = document.createElement('button');\n      muteButton.className = `mic-button ${this.isMicMuted ? 'muted' : ''}`;\n      muteButton.setAttribute('aria-label', this.isMicMuted ? 'Unmute microphone' : 'Mute microphone');\n      muteButton.setAttribute('data-role', 'mute');\n      muteButton.innerHTML = this.isMicMuted\n        ? '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-off-icon lucide-mic-off\"><path d=\"M12 19v3\"/><path d=\"M15 9.34V5a3 3 0 0 0-5.68-1.33\"/><path d=\"M16.95 16.95A7 7 0 0 1 5 12v-2\"/><path d=\"M18.89 13.23A7 7 0 0 0 19 12v-2\"/><path d=\"m2 2 20 20\"/><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12\"/></svg>'\n        : '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-icon lucide-mic\"><path d=\"M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\"/><path d=\"M19 10v1a7 7 0 0 1-14 0v-1\"/><path d=\"M12 19v3\"/><path d=\"M8 22h8\"/></svg>'\n      buttonsContainer.appendChild(hangUpButton);\n      buttonsContainer.appendChild(muteButton);\n      container.appendChild(buttonsContainer);\n    } else {\n      container.appendChild(micButton);\n    }\n\n    container.appendChild(textContainer);\n\n    if (menuContainer) {\n      // Position the menu container absolutely over the button area\n      container.style.position = 'relative';\n      container.appendChild(menuContainer);\n    }\n\n    // Hidden audio element with autoplay for remote stream (preserve across re-renders)\n    const existingAudioElement = this.audioOutputElement;\n    const existingStream = existingAudioElement?.srcObject || null;\n\n    if (existingAudioElement) {\n      this.audioOutputElement = existingAudioElement;\n    } else {\n      this.audioOutputElement = document.createElement('audio');\n      this.audioOutputElement.className = 'audio-element';\n      this.audioOutputElement.id = 'fastrtc-voice-widget-audio';\n      this.audioOutputElement.autoplay = true;\n      this.audioOutputElement.playsInline = true;\n      this.audioOutputElement.controls = false;\n      this.audioOutputElement.muted = false;\n      this.audioOutputElement.volume = 1.0;\n\n    // Add debugging events to audio element (only once per element)\n      this.audioOutputElement.addEventListener('error', (e) => {\n        console.error('Audio element error:', e);\n      });\n    }\n\n    // Add click handler to the widget container to enable audio playback (once)\n    if (!this.shadowClickListenerAdded) {\n      this.shadowRoot.addEventListener('click', () => {\n        if (this.audioOutputElement) {\n          if (this.audioOutputElement.muted) {\n            console.log('🔊 User clicked widget - attempting to unmute audio');\n            this.forceUnmuteAudio();\n          }\n          this.ensurePlayback();\n        }\n      });\n      this.shadowClickListenerAdded = true;\n    }\n\n    container.appendChild(this.audioOutputElement);\n\n    // If there was an existing stream attached before re-render, ensure it remains attached\n    if (existingStream && !this.audioOutputElement.srcObject) {\n      this.audioOutputElement.srcObject = existingStream;\n    }\n\n    this.shadowRoot.innerHTML = '';\n    this.shadowRoot.appendChild(style);\n    this.shadowRoot.appendChild(container);\n  }\n\n  updateUI() {\n    this.render();\n    this.setupEventListeners();\n  }\n\n  updateDeviceMenus() {\n    // This would update the radio button states in the device menu\n    const deviceMenu = this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      const inputRadios = deviceMenu.querySelectorAll('input[name=\"input-device\"]');\n      const outputRadios = deviceMenu.querySelectorAll('input[name=\"output-device\"]');\n\n      inputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedInputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n\n      outputRadios.forEach(radio => {\n        radio.checked = radio.value === this.selectedOutputDeviceId;\n        const option = radio.closest('.device-option');\n        option.classList.toggle('selected', radio.checked);\n      });\n    }\n  }\n\n  buildDeviceMenuContent(deviceMenu) {\n    if (!deviceMenu) return;\n\n    // Clear existing content\n    deviceMenu.innerHTML = '';\n\n    // Input devices section\n    const inputSection = document.createElement('div');\n    inputSection.className = 'device-menu-section';\n\n    const inputLabel = document.createElement('div');\n    inputLabel.className = 'device-menu-label';\n    inputLabel.textContent = 'Input Device';\n    inputSection.appendChild(inputLabel);\n\n    this.inputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedInputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'input-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedInputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleInputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      inputSection.appendChild(option);\n    });\n\n    // Output devices section\n    const outputSection = document.createElement('div');\n    outputSection.className = 'device-menu-section';\n\n    const outputLabel = document.createElement('div');\n    outputLabel.className = 'device-menu-label';\n    outputLabel.textContent = 'Output Device';\n    outputSection.appendChild(outputLabel);\n\n    this.outputDevices.forEach((device) => {\n      const option = document.createElement('div');\n      option.className = `device-option ${device.deviceId === this.selectedOutputDeviceId ? 'selected' : ''}`;\n\n      const radio = document.createElement('input');\n      radio.type = 'radio';\n      radio.name = 'output-device';\n      radio.value = device.deviceId || 'default';\n      radio.checked = device.deviceId === this.selectedOutputDeviceId;\n\n      const label = document.createElement('label');\n      label.textContent = device.label;\n\n      option.appendChild(radio);\n      option.appendChild(label);\n\n      option.addEventListener('click', () => {\n        this.handleOutputDeviceChange(device.deviceId || 'default');\n        deviceMenu.classList.remove('open');\n      });\n\n      outputSection.appendChild(option);\n    });\n\n    deviceMenu.appendChild(inputSection);\n    deviceMenu.appendChild(outputSection);\n  }\n\n  rebuildDeviceMenu() {\n    const deviceMenu = this.shadowRoot && this.shadowRoot.querySelector('.device-menu');\n    if (deviceMenu) {\n      this.buildDeviceMenuContent(deviceMenu);\n    }\n  }\n\n  setupEventListeners() {\n    // Main mic button (for start/stop)\n    const micButton = this.shadowRoot.querySelector('.mic-button[data-role=\"call\"]');\n    if (micButton) {\n      micButton.addEventListener('click', () => this.handleToggleVoiceChat());\n    }\n\n    // Hang up button (red)\n    const hangUpButton = this.shadowRoot.querySelector('.mic-button[data-role=\"hangup\"]');\n    if (hangUpButton && !hangUpButton.hasEventListener) {\n      hangUpButton.addEventListener('click', () => this.handleToggleVoiceChat());\n      hangUpButton.hasEventListener = true;\n    }\n\n    // Mute button (toggle)\n    const muteButton = this.shadowRoot.querySelector('.mic-button[data-role=\"mute\"]');\n    if (muteButton && !muteButton.hasEventListener) {\n      muteButton.addEventListener('click', () => {\n        this.handleMuteToggle();\n        // Update icon and class immediately to reflect state\n        const isMutedNow = this.isMicMuted;\n        muteButton.classList.toggle('muted', isMutedNow);\n        muteButton.setAttribute('aria-label', isMutedNow ? 'Unmute microphone' : 'Mute microphone');\n        muteButton.innerHTML = isMutedNow\n          ? '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-off-icon lucide-mic-off\"><path d=\"M12 19v3\"/><path d=\"M15 9.34V5a3 3 0 0 0-5.68-1.33\"/><path d=\"M16.95 16.95A7 7 0 0 1 5 12v-2\"/><path d=\"M18.89 13.23A7 7 0 0 0 19 12v-2\"/><path d=\"m2 2 20 20\"/><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12\"/></svg>'\n          : '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-mic-icon lucide-mic\"><path d=\"M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\"/><path d=\"M19 10v1a7 7 0 0 1-14 0v-1\"/><path d=\"M12 19v3\"/><path d=\"M8 22h8\"/></svg>';\n      });\n      muteButton.hasEventListener = true;\n    }\n  }\n\n  cleanup() {\n    this.shutdownWebRTC();\n\n    if (this.audioOutputElement) {\n      console.log('Cleaning up audio element');\n      this.audioOutputElement.srcObject = null;\n      this.audioOutputElement.pause();\n    }\n    this.playbackStarted = false;\n  }\n\n  // Force unmute audio element with multiple techniques\n  forceUnmuteAudio() {\n    if (!this.audioOutputElement) {\n      console.error('Audio element not found');\n      return;\n    }\n\n    // Method 1: Direct property setting\n    this.audioOutputElement.muted = false;\n    this.audioOutputElement.volume = 1.0;\n\n    // Method 2: Try to set sink ID (for output device control)\n    if (this.audioOutputElement.setSinkId && this.selectedOutputDeviceId) {\n      this.audioOutputElement.setSinkId(this.selectedOutputDeviceId).catch(() => {});\n    }\n\n    // Method 3: Delegate actual playback to a single unified handler\n    \n\n    this.ensurePlayback();\n    \n  }\n\n  // Ensure playback starts only once to avoid overlapping play() calls\n  ensurePlayback() {\n    if (!this.audioOutputElement || this.playbackStarted === true) return;\n    if (!this.audioOutputElement.srcObject) return;\n\n    if (this.audioOutputElement.paused) {\n      const playPromise = this.audioOutputElement.play();\n      if (playPromise !== undefined) {\n        playPromise.then(() => {\n          this.playbackStarted = true;\n        }).catch(error => {\n          \n        });\n      }\n    } else {\n      this.playbackStarted = true;\n    }\n  }\n\n  // Debug method to check audio status\n  debugAudioStatus() {\n    console.group('🔊 Audio Status Debug');\n    console.log('Audio element exists:', !!this.audioOutputElement);\n    console.log('Audio element muted:', this.audioOutputElement?.muted);\n    console.log('Audio element volume:', this.audioOutputElement?.volume);\n    console.log('Audio element srcObject:', this.audioOutputElement?.srcObject);\n    console.log('Audio element paused:', this.audioOutputElement?.paused);\n    console.log('Audio element readyState:', this.audioOutputElement?.readyState);\n    console.log('WebRTC connected:', this.isWebRTCConnected);\n    console.log('Peer connection state:', this.peerConnection?.connectionState);\n    console.log('Current stream tracks:', this.currentStream?.getTracks().length || 0);\n    console.log('Peer connection senders:', this.peerConnection?.getSenders().length || 0);\n\n    if (this.peerConnection) {\n      const receivers = this.peerConnection.getReceivers();\n      console.log('Peer connection receivers:', receivers.length);\n      receivers.forEach((receiver, index) => {\n        console.log(`Receiver ${index}:`, {\n          track: receiver.track ? {\n            kind: receiver.track.kind,\n            id: receiver.track.id,\n            enabled: receiver.track.enabled,\n            readyState: receiver.track.readyState\n          } : null\n        });\n      });\n    }\n\n    if (this.audioOutputElement?.srcObject) {\n      const stream = this.audioOutputElement.srcObject;\n      console.log('Audio stream details:', {\n        id: stream.id,\n        active: stream.active,\n        tracks: stream.getTracks().map(t => ({\n          kind: t.kind,\n          id: t.id,\n          enabled: t.enabled,\n          readyState: t.readyState\n        }))\n      });\n    }\n\n    console.groupEnd();\n  }\n}\n\n// Register the web component\nif (!customElements.get('fastrtc-voice-widget')) {\n  customElements.define('fastrtc-voice-widget', FastRTCVoiceWidget);\n}\n\n// Rely on the browser's native custom element upgrade lifecycle\n\n// Export for use in other contexts\nwindow.FastRTCVoiceWidget = FastRTCVoiceWidget;\n"],"names":["FastRTCVoiceWidget","HTMLElement","constructor","super","this","attachShadow","mode","isWebRTCConnected","isConnecting","peerConnection","currentStream","dataChannel","audioOutputElement","shadowClickListenerAdded","playbackStarted","debugEnabled","inputDevices","outputDevices","selectedInputDeviceId","selectedOutputDeviceId","isExpanded","isMicMuted","observedAttributes","attributeChangedCallback","name","oldValue","newValue","hasAttribute","debugLog","args","console","log","connectedCallback","apiUrl","getAttribute","authToken","showDeviceSelection","render","setupEventListeners","error","disconnectedCallback","cleanup","getTurnCredentials","response","fetch","headers","ok","Error","status","json","iceServers","urls","enumerateDevices","navigator","mediaDevices","getUserMedia","audio","noiseSuppression","echoCancellation","autoGainControl","getTracks","forEach","track","stop","micError","devices","filter","device","kind","map","deviceId","label","trim","length","rebuildDeviceMenu","updateDeviceMenus","warn","setupWebRTC","constraints","exact","stream","RTCPeerConnection","addTrack","addEventListener","evt","srcObject","streams","volume","muted","ensurePlayback","createDataChannel","onopen","updateUI","forceUnmuteAudio","onclose","onerror","onmessage","event","offer","createOffer","setLocalDescription","webrtcId","Math","random","toString","substring","onicecandidate","candidate","method","body","JSON","stringify","toJSON","webrtc_id","type","oniceconnectionstatechange","iceConnectionState","onconnectionstatechange","connectionState","sdp","serverResponse","answer","RTCSessionDescription","setRemoteDescription","parseError","message","alert","includes","shutdownWebRTC","getSenders","sender","close","handleToggleVoiceChat","handleInputDeviceChange","selected","find","d","note","newStream","s","getAudioTracks","replaceTrack","originalDevice","handleOutputDeviceChange","setSinkId","handleMuteToggle","audioTracks","enabled","container","document","createElement","className","style","textContent","micButton","setAttribute","classList","add","srText","innerHTML","appendChild","textContainer","primaryText","secondaryText","display","menuContainer","settingsButton","deviceMenu","buildDeviceMenuContent","async","e","stopPropagation","toggle","contains","target","remove","buttonsContainer","hangUpButton","muteButton","position","existingAudioElement","existingStream","id","autoplay","playsInline","controls","shadowRoot","querySelector","inputRadios","querySelectorAll","outputRadios","radio","checked","value","closest","inputSection","inputLabel","option","outputSection","outputLabel","hasEventListener","isMutedNow","pause","catch","paused","playPromise","play","then","debugAudioStatus","group","_a","_b","_c","_d","_e","readyState","_f","_g","_h","receivers","getReceivers","receiver","index","_i","active","tracks","t","groupEnd","customElements","get","define","window"],"mappings":"0FACA,MAAMA,UAA2BC,YAC/B,WAAAC,GACEC,QACAC,KAAKC,aAAa,CAAEC,KAAM,SAC1BF,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKK,eAAiB,KACtBL,KAAKM,cAAgB,KACrBN,KAAKO,YAAc,KACnBP,KAAKQ,mBAAqB,KAC1BR,KAAKS,0BAA2B,EAChCT,KAAKU,iBAAkB,EACvBV,KAAKW,cAAe,EAGpBX,KAAKY,aAAe,GACpBZ,KAAKa,cAAgB,GACrBb,KAAKc,sBAAwB,GAC7Bd,KAAKe,uBAAyB,GAG9Bf,KAAKgB,YAAa,EAClBhB,KAAKiB,YAAa,CACpB,CAEA,6BAAWC,GACT,MAAO,CAAC,QACV,CAEA,wBAAAC,CAAyBC,EAAMC,EAAUC,GAC1B,UAATF,IACFpB,KAAKW,aAAeX,KAAKuB,aAAa,SAE1C,CAEA,QAAAC,IAAYC,GACNzB,KAAKW,cACPe,QAAQC,OAAOF,EAEnB,CAEA,iBAAAG,GACE,IACE5B,KAAK6B,OAAS7B,KAAK8B,aAAa,YAAc,GAC9C9B,KAAK+B,UAAY/B,KAAK8B,aAAa,eAAiB,GACpD9B,KAAKgC,oBAAsBhC,KAAKuB,aAAa,yBAC7CvB,KAAKW,aAAeX,KAAKuB,aAAa,SAGpCvB,KAAKuB,aAAa,kBACpBvB,KAAKG,mBAAoB,GAGzBH,KAAKiC,SACLjC,KAAKkC,qBAEP,OAASC,GACPT,QAAQS,MAAM,8BAA+BA,EAC/C,CACF,CAEA,oBAAAC,GACEpC,KAAKqC,SACP,CAGA,wBAAMC,GACJ,IACE,MAAMC,QAAiBC,MAAM,GAAGxC,KAAK6B,iCAAkC,CACrEY,QAAS,CACP,eAAgB,sBAIpB,IAAKF,EAASG,GACZ,MAAM,IAAIC,MAAM,mCAAmCJ,EAASK,UAE9D,aAAaL,EAASM,MACxB,OAASV,GAEP,OADAT,QAAQS,MAAM,mCAAoCA,GAC3C,CACLW,WAAY,CACV,CAAEC,KAAM,iCAGd,CACF,CAEA,sBAAMC,GAEJ,GAAKC,UAAUC,cAAiBD,UAAUC,aAAaF,iBAKvD,IAGE,WACuBC,UAAUC,aAAaC,aAAa,CACvDC,MAAO,CACLC,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,MAIdC,YAAYC,QAAQC,GAASA,EAAMC,QAC1CjC,QAAQC,IAAI,mDACd,OAASiC,GAET,CAGA,MAAMC,QAAgBZ,UAAUC,aAAaF,mBAE7ChD,KAAKY,aAAeiD,EACjBC,OAAOC,GAA0B,eAAhBA,EAAOC,MACxBC,IAAKF,IAAA,CACJG,SAAUH,EAAOG,SACjBC,MAAQJ,EAAOI,OAASJ,EAAOI,MAAMC,OACjCL,EAAOI,MAAMC,OACQ,YAApBL,EAAOG,SAAyB,qBAAuB,wBAGhElE,KAAKa,cAAgBgD,EAClBC,OAAOC,GAA0B,gBAAhBA,EAAOC,MACxBC,IAAKF,IAAA,CACJG,SAAUH,EAAOG,SACjBC,MAAQJ,EAAOI,OAASJ,EAAOI,MAAMC,OACjCL,EAAOI,MAAMC,OACQ,YAApBL,EAAOG,SAAyB,kBAAoB,sBAKxDlE,KAAKc,uBAAyBd,KAAKY,aAAayD,OAAS,IAC5DrE,KAAKc,sBAAwBd,KAAKY,aAAa,GAAGsD,UAAY,YAE3DlE,KAAKe,wBAA0Bf,KAAKa,cAAcwD,OAAS,IAC9DrE,KAAKe,uBAAyBf,KAAKa,cAAc,GAAGqD,UAAY,WAGlElE,KAAKsE,oBACLtE,KAAKuE,mBACP,OAASpC,GACPT,QAAQS,MAAM,6BAA8BA,GAGzB,oBAAfA,EAAMf,MAERpB,KAAKY,aAAe,CAAC,CACnBsD,SAAU,UACVC,MAAO,uBAETnE,KAAKa,cAAgB,CAAC,CACpBqD,SAAU,UACVC,MAAO,sBAKTnE,KAAKY,aAAe,CAAC,CACnBsD,SAAU,GACVC,MAAO,2BAETnE,KAAKa,cAAgB,CAAC,CACpBqD,SAAU,GACVC,MAAO,yBAKXnE,KAAKsE,oBACLtE,KAAKuE,mBACP,MApFE7C,QAAQ8C,KAAK,iCAqFjB,CAEA,iBAAMC,GACJ,GAAKzE,KAAKQ,mBAKV,IACE,MAAMkE,EAAc,CAClBtB,MAAOpD,KAAKc,sBAAwB,CAClCoD,SAAU,CAAES,MAAO3E,KAAKc,uBACxBuC,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,GACf,CACFF,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,IAIfqB,QAAe3B,UAAUC,aAAaC,aAAauB,GAGzD1E,KAAKM,cAAgBsE,EACrB5E,KAAKK,eAAiB,IAAIwE,wBAAwB7E,KAAKsC,sBAGvDsC,EAAOpB,YAAYC,QAAQC,IACzB1D,KAAKK,eAAeyE,SAASpB,EAAOkB,KAItC5E,KAAKK,eAAe0E,iBAAiB,QAAUC,IAEtB,UAAnBA,EAAItB,MAAMM,OACRhE,KAAKQ,mBACHR,KAAKQ,mBAAmByE,YAAcD,EAAIE,QAAQ,KAEpDlF,KAAKU,iBAAkB,EACvBV,KAAKQ,mBAAmByE,UAAYD,EAAIE,QAAQ,GAGhDlF,KAAKQ,mBAAmB2E,OAAS,EACjCnF,KAAKQ,mBAAmB4E,OAAQ,EAEhCpF,KAAKqF,kBAKP3D,QAAQS,MAAM,iCAQpBnC,KAAKO,YAAcP,KAAKK,eAAeiF,kBAAkB,QACzDtF,KAAKO,YAAYgF,OAAS,KAEnBvF,KAAKG,oBACRH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,WAGLxF,KAAKyF,qBAGTzF,KAAKO,YAAYmF,QAAU,OAC3B1F,KAAKO,YAAYoF,QAAWxD,GAAUT,QAAQS,MAAM,sBAAuBA,GAC3EnC,KAAKO,YAAYqF,UAAaC,IAEvB7F,KAAKG,oBACRH,KAAKG,mBAAoB,EACzBH,KAAKwF,WAGLxF,KAAKyF,qBAKT,MAAMK,QAAc9F,KAAKK,eAAe0F,oBAClC/F,KAAKK,eAAe2F,oBAAoBF,GAE9C,MACMG,EADWC,KAAKC,SAASC,SAAS,IAAIC,UAAU,GAItDrG,KAAKK,eAAeiG,eAAiB,EAAGC,gBAClCA,GACF/D,MAAM,GAAGxC,KAAK6B,sBAAuB,CACnC2E,OAAQ,OACR/D,QAAS,CACP,eAAgB,oBAElBgE,KAAMC,KAAKC,UAAU,CACnBJ,UAAWA,EAAUK,SACrBC,UAAWZ,EACXa,KAAM,qBAMd9G,KAAKK,eAAe0G,2BAA6B,KAGA,cAA3C/G,KAAKK,eAAe2G,oBACuB,cAA3ChH,KAAKK,eAAe2G,mBACjBhH,KAAKG,oBACRH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,WAGLxF,KAAKyF,oBAE6C,WAA3CzF,KAAKK,eAAe2G,oBACuB,iBAA3ChH,KAAKK,eAAe2G,qBAC7BhH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,aAITxF,KAAKK,eAAe4G,wBAA0B,KAEA,cAAxCjH,KAAKK,eAAe6G,iBACtBlH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,WAGLxF,KAAKyF,oBAC4C,eAAxCzF,KAAKK,eAAe6G,iBAEoB,QAAxClH,KAAKK,eAAe6G,kBAEoB,WAAxClH,KAAKK,eAAe6G,iBAC7BlH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,YAC4C,iBAAxCxF,KAAKK,eAAe6G,iBACoB,WAAxClH,KAAKK,eAAe6G,kBAC7BlH,KAAKG,mBAAoB,EACzBH,KAAKI,cAAe,EACpBJ,KAAKwF,cAKT,MAAMjD,QAAiBC,MAAM,GAAGxC,KAAK6B,sBAAuB,CAC1D2E,OAAQ,OACR/D,QAAS,CACP,eAAgB,oBAElBgE,KAAMC,KAAKC,UAAU,CACnBQ,IAAKrB,EAAMqB,IACXL,KAAMhB,EAAMgB,KACZD,UAAWZ,MAIf,IAAImB,EACJ,IAIE,GAHAA,QAAuB7E,EAASM,QAG3BuE,GAA4C,iBAAnBA,EAC5B,MAAM,IAAIzE,MAAM,0CAGlB,IAAKyE,EAAeD,MAAQC,EAAeN,KACzC,MAAM,IAAInE,MAAM,gDAIlB,MAAM0E,EAAS,IAAIC,sBAAsB,CACvCR,KAAMM,EAAeN,KACrBK,IAAKC,EAAeD,YAGhBnH,KAAKK,eAAekH,qBAAqBF,EAEjD,OAASG,GAIP,MAFA9F,QAAQS,MAAM,iCAAkCqF,GAChD9F,QAAQS,MAAM,uBAAwBiF,GAChC,IAAIzE,MAAM,oCAAoC6E,EAAWC,UACjE,CAEF,OAAStF,GACPT,QAAQS,MAAM,iCAAkCA,GAG7B,oBAAfA,EAAMf,KACRsG,MAAM,sFACkB,kBAAfvF,EAAMf,KACfsG,MAAM,mEACkB,qBAAfvF,EAAMf,KACfsG,MAAM,8FACGvF,EAAMsF,QAAQE,SAAS,uCAChCD,MAAM,wFACNhG,QAAQS,MAAM,uBAAwBiF,iBAEtCM,MAAM,6BAA+BvF,EAAMsF,SAI7CzH,KAAKG,mBAAoB,EACzBH,KAAKwF,UACP,MApNE9D,QAAQS,MAAM,iCAqNlB,CAEA,oBAAMyF,GAGJ,GAFAlG,QAAQC,IAAI,sCAER3B,KAAKK,eAAgB,CACPL,KAAKK,eAAewH,aAC5BpE,QAAQqE,IACVA,EAAOpE,QACThC,QAAQC,IAAI,mBAAmBmG,EAAOpE,MAAMM,QAC5C8D,EAAOpE,MAAMC,UAIjB3D,KAAKK,eAAe0H,QACpB/H,KAAKK,eAAiB,IACxB,CAEIL,KAAKM,gBACPN,KAAKM,cAAckD,YAAYC,QAAQC,IACrCA,EAAMC,SAER3D,KAAKM,cAAgB,MAGvBoB,QAAQC,IAAI,4DACZ3B,KAAKG,mBAAoB,EACzBH,KAAKwF,UACP,CAEA,2BAAMwC,GACJ,GAAIhI,KAAKG,wBACDH,KAAK4H,qBACN,CACL,GAAI5H,KAAKI,aAEP,YADAsB,QAAQC,IAAI,2CAMd3B,KAAKI,cAAe,EACpBJ,KAAKwF,WACL9D,QAAQC,IAAI,2CAEZ,UACQ3B,KAAKyE,aAGb,OAAStC,GACPT,QAAQS,MAAM,4BAA6BA,GAE3CnC,KAAKI,cAAe,EACpBJ,KAAKwF,UACP,CAGF,CACF,CAEA,6BAAMyC,CAAwB/D,GAE5B,IAAKA,GAAyB,KAAbA,EAEf,YADAxC,QAAQ8C,KAAK,2BAA4BN,GAI3C,MAAMgE,EAAWlI,KAAKY,aAAauH,SAAWC,EAAElE,UAAY,aAAeA,GAO3E,GANAxC,QAAQC,IAAI,8BAA+BuG,GAAY,CAAEhE,WAAUmE,KAAM,8BAEzErI,KAAKc,sBAAwBoD,EAC7BlE,KAAKuE,oBAGDvE,KAAKG,mBAAqBH,KAAKK,gBAAkBL,KAAKM,cACxD,IACEoB,QAAQC,IAAI,8BAA8BuC,KAG1C,MAAMQ,EAAc,CAClBtB,MAAOc,GAAyB,YAAbA,EAAyB,CAC1CA,SAAU,CAAES,MAAOT,GACnBb,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,GACf,CACFF,kBAAkB,EAClBC,kBAAkB,EAClBC,iBAAiB,IAIf+E,QAAkBrF,UAAUC,aAAaC,aAAauB,GAC5DhD,QAAQC,IAAI,mCAGZ3B,KAAKM,cAAckD,YAAYC,QAAQC,IACrCA,EAAMC,SAIR,MAAMmE,EAAS9H,KAAKK,eAAewH,aAAaM,KAAKI,GACnDA,EAAE7E,OAA0B,UAAjB6E,EAAE7E,MAAMM,MAGjB8D,GAAUQ,EAAUE,iBAAiBnE,OAAS,SAC1CyD,EAAOW,aAAaH,EAAUE,iBAAiB,IACrD9G,QAAQC,IAAI,uCAEZD,QAAQS,MAAM,mDAIhBnC,KAAKM,cAAgBgI,CAEvB,OAASnG,GACPT,QAAQS,MAAM,iDAAkDA,GAEhE,MAAMuG,EAAiB1I,KAAKc,sBAC5Bd,KAAKc,sBAAwB4H,EAC7B1I,KAAKuE,mBACP,CAEJ,CAEA,8BAAMoE,CAAyBzE,GAE7B,IAAKA,GAAyB,KAAbA,EAEf,YADAxC,QAAQ8C,KAAK,4BAA6BN,GAI5C,MAAMgE,EAAWlI,KAAKa,cAAcsH,SAAWC,EAAElE,UAAY,aAAeA,GAM5E,GALAxC,QAAQC,IAAI,+BAAgCuG,GAAY,CAAEhE,WAAUmE,KAAM,+BAE1ErI,KAAKe,uBAAyBmD,EAC9BlE,KAAKuE,oBAEDvE,KAAKQ,oBAAsBR,KAAKQ,mBAAmBoI,UACrD,IAEmB,YAAb1E,SACIlE,KAAKQ,mBAAmBoI,UAAU1E,GACxCxC,QAAQC,IAAI,mCAAmCuC,MAE/CxC,QAAQC,IAAI,oCAEhB,OAASQ,GACPT,QAAQS,MAAM,qCAAsCA,EACtD,MAEAT,QAAQ8C,KAAK,2DAEjB,CAEA,sBAAMqE,GACJ,GAAK7I,KAAKG,mBAAsBH,KAAKK,gBAAmBL,KAAKM,cAK7D,IAEE,MAAMwI,EAAc9I,KAAKM,cAAckI,iBAEvC,GAA2B,IAAvBM,EAAYzE,OAEd,YADA3C,QAAQ8C,KAAK,2CAKfxE,KAAKiB,YAAcjB,KAAKiB,WAGxB6H,EAAYrF,QAAQC,IAClBA,EAAMqF,SAAW/I,KAAKiB,aAGxBS,QAAQC,IAAI,eAAc3B,KAAKiB,WAAa,QAAU,YAGvCjB,KAAKK,eAAewH,aAAaM,KAAKI,GACnDA,EAAE7E,OAA0B,UAAjB6E,EAAE7E,MAAMM,OAOnBtC,QAAQC,IAAI,0CAGd3B,KAAKwF,UACP,OAASrD,GACPT,QAAQS,MAAM,uBAAwBA,GAEtCnC,KAAKiB,YAAcjB,KAAKiB,WACxBjB,KAAKwF,UACP,MAzCE9D,QAAQ8C,KAAK,kDA0CjB,CAGA,MAAAvC,GACE,MAAM+G,EAAYC,SAASC,cAAc,OACzCF,EAAUG,UAAY,mBAEtB,MAAMC,EAAQH,SAASC,cAAc,SACrCE,EAAMC,YAAc,6zKA0OpB,MAAMC,EAAYL,SAASC,cAAc,UACzCI,EAAUH,UAAY,cAAcnJ,KAAKG,kBAAoB,SAAW,MAAMH,KAAKI,aAAe,aAAe,KACjHkJ,EAAUC,aAAa,aAAcvJ,KAAKG,kBAAoB,kBAAoB,oBAClFmJ,EAAUC,aAAa,YAAa,QAEhCvJ,KAAKI,eAAiBJ,KAAKG,mBAC7BmJ,EAAUE,UAAUC,IAAI,wBAI1B,MAAMC,EAAST,SAASC,cAAc,QACtCQ,EAAOP,UAAY,UACnBO,EAAOL,YAAcrJ,KAAKG,kBAAoB,kBAAoB,mBAKlEmJ,EAAUK,UAFO,6cAGjBL,EAAUM,YAAYF,GAGtB,MAAMG,EAAgBZ,SAASC,cAAc,OAC7CW,EAAcV,UAAY,iBAE1B,MAAMW,EAAcb,SAASC,cAAc,KAC3CY,EAAYX,UAAY,eACxBW,EAAYT,YAAerJ,KAAKI,eAAiBJ,KAAKG,kBAAqB,gBAAkBH,KAAKG,kBAAoB,YAAc,kBAEpI,MAAM4J,EAAgBd,SAASC,cAAc,KAC7Ca,EAAcZ,UAAY,iBAC1BY,EAAcV,YAAc,sBACvBrJ,KAAKG,oBACR4J,EAAcX,MAAMY,QAAU,QAGhCH,EAAcD,YAAYE,GAC1BD,EAAcD,YAAYG,GAG1B,IAAIE,EAAgB,KACpB,GAAIjK,KAAKgC,oBAAqB,CAC5BiI,EAAgBhB,SAASC,cAAc,OACvCe,EAAcd,UAAY,iBAE1B,MAAMe,EAAiBjB,SAASC,cAAc,UAC9CgB,EAAef,UAAY,kBAC3Be,EAAeX,aAAa,aAAc,mBAC1CW,EAAeP,UAAY,omBAE3B,MAAMQ,EAAalB,SAASC,cAAc,OAC1CiB,EAAWhB,UAAY,cACvBnJ,KAAKoK,uBAAuBD,GAE5BD,EAAenF,iBAAiB,QAASsF,MAAOC,IAC9CA,EAAEC,kBAG+B,IAA7BvK,KAAKY,aAAayD,QAA8C,IAA9BrE,KAAKa,cAAcwD,SACvD3C,QAAQC,IAAI,0DACN3B,KAAKgD,oBAGbmH,EAAWX,UAAUgB,OAAO,UAI9BvB,SAASlE,iBAAiB,QAAUuF,IAC7BL,EAAcQ,SAASH,EAAEI,SAC5BP,EAAWX,UAAUmB,OAAO,UAIhCV,EAAcL,YAAYM,GAC1BD,EAAcL,YAAYO,EAC5B,CAGA,GAAInK,KAAKG,kBAAmB,CAC1B,MAAMyK,EAAmB3B,SAASC,cAAc,OAChD0B,EAAiBzB,UAAY,iBAG7B,MAAM0B,EAAe5B,SAASC,cAAc,UAC5C2B,EAAa1B,UAAY,oBACzB0B,EAAatB,aAAa,aAAc,WACxCsB,EAAatB,aAAa,YAAa,UACvCsB,EAAalB,UAAY,6iBAGzB,MAAMmB,EAAa7B,SAASC,cAAc,UAC1C4B,EAAW3B,UAAY,eAAcnJ,KAAKiB,WAAa,QAAU,IACjE6J,EAAWvB,aAAa,aAAcvJ,KAAKiB,WAAa,oBAAsB,mBAC9E6J,EAAWvB,aAAa,YAAa,QACrCuB,EAAWnB,UAAY3J,KAAKiB,WACxB,+bACA,qXACJ2J,EAAiBhB,YAAYiB,GAC7BD,EAAiBhB,YAAYkB,GAC7B9B,EAAUY,YAAYgB,EACxB,MACE5B,EAAUY,YAAYN,GAGxBN,EAAUY,YAAYC,GAElBI,IAEFjB,EAAUI,MAAM2B,SAAW,WAC3B/B,EAAUY,YAAYK,IAIxB,MAAMe,EAAuBhL,KAAKQ,mBAC5ByK,SAAiBD,WAAsB/F,YAAa,KAEtD+F,EACFhL,KAAKQ,mBAAqBwK,GAE1BhL,KAAKQ,mBAAqByI,SAASC,cAAc,SACjDlJ,KAAKQ,mBAAmB2I,UAAY,gBACpCnJ,KAAKQ,mBAAmB0K,GAAK,6BAC7BlL,KAAKQ,mBAAmB2K,UAAW,EACnCnL,KAAKQ,mBAAmB4K,aAAc,EACtCpL,KAAKQ,mBAAmB6K,UAAW,EACnCrL,KAAKQ,mBAAmB4E,OAAQ,EAChCpF,KAAKQ,mBAAmB2E,OAAS,EAGjCnF,KAAKQ,mBAAmBuE,iBAAiB,QAAUuF,IACjD5I,QAAQS,MAAM,uBAAwBmI,MAKrCtK,KAAKS,2BACRT,KAAKsL,WAAWvG,iBAAiB,QAAS,KACpC/E,KAAKQ,qBACHR,KAAKQ,mBAAmB4E,QAC1B1D,QAAQC,IAAI,uDACZ3B,KAAKyF,oBAEPzF,KAAKqF,oBAGTrF,KAAKS,0BAA2B,GAGlCuI,EAAUY,YAAY5J,KAAKQ,oBAGvByK,IAAmBjL,KAAKQ,mBAAmByE,YAC7CjF,KAAKQ,mBAAmByE,UAAYgG,GAGtCjL,KAAKsL,WAAW3B,UAAY,GAC5B3J,KAAKsL,WAAW1B,YAAYR,GAC5BpJ,KAAKsL,WAAW1B,YAAYZ,EAC9B,CAEA,QAAAxD,GACExF,KAAKiC,SACLjC,KAAKkC,qBACP,CAEA,iBAAAqC,GAEE,MAAM4F,EAAanK,KAAKsL,WAAWC,cAAc,gBACjD,GAAIpB,EAAY,CACd,MAAMqB,EAAcrB,EAAWsB,iBAAiB,8BAC1CC,EAAevB,EAAWsB,iBAAiB,+BAEjDD,EAAY/H,QAAQkI,IAClBA,EAAMC,QAAUD,EAAME,QAAU7L,KAAKc,sBACtB6K,EAAMG,QAAQ,kBACtBtC,UAAUgB,OAAO,WAAYmB,EAAMC,WAG5CF,EAAajI,QAAQkI,IACnBA,EAAMC,QAAUD,EAAME,QAAU7L,KAAKe,uBACtB4K,EAAMG,QAAQ,kBACtBtC,UAAUgB,OAAO,WAAYmB,EAAMC,UAE9C,CACF,CAEA,sBAAAxB,CAAuBD,GACrB,IAAKA,EAAY,OAGjBA,EAAWR,UAAY,GAGvB,MAAMoC,EAAe9C,SAASC,cAAc,OAC5C6C,EAAa5C,UAAY,sBAEzB,MAAM6C,EAAa/C,SAASC,cAAc,OAC1C8C,EAAW7C,UAAY,oBACvB6C,EAAW3C,YAAc,eACzB0C,EAAanC,YAAYoC,GAEzBhM,KAAKY,aAAa6C,QAASM,IACzB,MAAMkI,EAAShD,SAASC,cAAc,OACtC+C,EAAO9C,UAAY,kBAAiBpF,EAAOG,WAAalE,KAAKc,sBAAwB,WAAa,IAElG,MAAM6K,EAAQ1C,SAASC,cAAc,SACrCyC,EAAM7E,KAAO,QACb6E,EAAMvK,KAAO,eACbuK,EAAME,MAAQ9H,EAAOG,UAAY,UACjCyH,EAAMC,QAAU7H,EAAOG,WAAalE,KAAKc,sBAEzC,MAAMqD,EAAQ8E,SAASC,cAAc,SACrC/E,EAAMkF,YAActF,EAAOI,MAE3B8H,EAAOrC,YAAY+B,GACnBM,EAAOrC,YAAYzF,GAEnB8H,EAAOlH,iBAAiB,QAAS,KAC/B/E,KAAKiI,wBAAwBlE,EAAOG,UAAY,WAChDiG,EAAWX,UAAUmB,OAAO,UAG9BoB,EAAanC,YAAYqC,KAI3B,MAAMC,EAAgBjD,SAASC,cAAc,OAC7CgD,EAAc/C,UAAY,sBAE1B,MAAMgD,EAAclD,SAASC,cAAc,OAC3CiD,EAAYhD,UAAY,oBACxBgD,EAAY9C,YAAc,gBAC1B6C,EAActC,YAAYuC,GAE1BnM,KAAKa,cAAc4C,QAASM,IAC1B,MAAMkI,EAAShD,SAASC,cAAc,OACtC+C,EAAO9C,UAAY,kBAAiBpF,EAAOG,WAAalE,KAAKe,uBAAyB,WAAa,IAEnG,MAAM4K,EAAQ1C,SAASC,cAAc,SACrCyC,EAAM7E,KAAO,QACb6E,EAAMvK,KAAO,gBACbuK,EAAME,MAAQ9H,EAAOG,UAAY,UACjCyH,EAAMC,QAAU7H,EAAOG,WAAalE,KAAKe,uBAEzC,MAAMoD,EAAQ8E,SAASC,cAAc,SACrC/E,EAAMkF,YAActF,EAAOI,MAE3B8H,EAAOrC,YAAY+B,GACnBM,EAAOrC,YAAYzF,GAEnB8H,EAAOlH,iBAAiB,QAAS,KAC/B/E,KAAK2I,yBAAyB5E,EAAOG,UAAY,WACjDiG,EAAWX,UAAUmB,OAAO,UAG9BuB,EAActC,YAAYqC,KAG5B9B,EAAWP,YAAYmC,GACvB5B,EAAWP,YAAYsC,EACzB,CAEA,iBAAA5H,GACE,MAAM6F,EAAanK,KAAKsL,YAActL,KAAKsL,WAAWC,cAAc,gBAChEpB,GACFnK,KAAKoK,uBAAuBD,EAEhC,CAEA,mBAAAjI,GAEE,MAAMoH,EAAYtJ,KAAKsL,WAAWC,cAAc,iCAC5CjC,GACFA,EAAUvE,iBAAiB,QAAS,IAAM/E,KAAKgI,yBAIjD,MAAM6C,EAAe7K,KAAKsL,WAAWC,cAAc,mCAC/CV,IAAiBA,EAAauB,mBAChCvB,EAAa9F,iBAAiB,QAAS,IAAM/E,KAAKgI,yBAClD6C,EAAauB,kBAAmB,GAIlC,MAAMtB,EAAa9K,KAAKsL,WAAWC,cAAc,iCAC7CT,IAAeA,EAAWsB,mBAC5BtB,EAAW/F,iBAAiB,QAAS,KACnC/E,KAAK6I,mBAEL,MAAMwD,EAAarM,KAAKiB,WACxB6J,EAAWtB,UAAUgB,OAAO,QAAS6B,GACrCvB,EAAWvB,aAAa,aAAc8C,EAAa,oBAAsB,mBACzEvB,EAAWnB,UAAY0C,EACnB,+bACA,uXAENvB,EAAWsB,kBAAmB,EAElC,CAEA,OAAA/J,GACErC,KAAK4H,iBAED5H,KAAKQ,qBACPkB,QAAQC,IAAI,6BACZ3B,KAAKQ,mBAAmByE,UAAY,KACpCjF,KAAKQ,mBAAmB8L,SAE1BtM,KAAKU,iBAAkB,CACzB,CAGA,gBAAA+E,GACOzF,KAAKQ,oBAMVR,KAAKQ,mBAAmB4E,OAAQ,EAChCpF,KAAKQ,mBAAmB2E,OAAS,EAG7BnF,KAAKQ,mBAAmBoI,WAAa5I,KAAKe,wBAC5Cf,KAAKQ,mBAAmBoI,UAAU5I,KAAKe,wBAAwBwL,MAAM,QAMvEvM,KAAKqF,kBAhBH3D,QAAQS,MAAM,0BAkBlB,CAGA,cAAAkD,GACE,GAAKrF,KAAKQ,qBAA+C,IAAzBR,KAAKU,iBAChCV,KAAKQ,mBAAmByE,UAE7B,GAAIjF,KAAKQ,mBAAmBgM,OAAQ,CAClC,MAAMC,EAAczM,KAAKQ,mBAAmBkM,YACxB,IAAhBD,GACFA,EAAYE,KAAK,KACf3M,KAAKU,iBAAkB,IACtB6L,MAAMpK,MAIb,MACEnC,KAAKU,iBAAkB,CAE3B,CAGA,gBAAAkM,yBAaE,GAZAlL,QAAQmL,MAAM,yBACdnL,QAAQC,IAAI,0BAA2B3B,KAAKQ,oBAC5CkB,QAAQC,IAAI,uBAAwB,OAAAmL,EAAA9M,KAAKQ,6BAAoB4E,OAC7D1D,QAAQC,IAAI,wBAAyB,OAAAoL,EAAA/M,KAAKQ,6BAAoB2E,QAC9DzD,QAAQC,IAAI,2BAA4B,OAAAqL,EAAAhN,KAAKQ,6BAAoByE,WACjEvD,QAAQC,IAAI,wBAAyB,OAAAsL,EAAAjN,KAAKQ,6BAAoBgM,QAC9D9K,QAAQC,IAAI,4BAA6B,OAAAuL,EAAAlN,KAAKQ,6BAAoB2M,YAClEzL,QAAQC,IAAI,oBAAqB3B,KAAKG,mBACtCuB,QAAQC,IAAI,yBAA0B,OAAAyL,EAAApN,KAAKK,yBAAgB6G,iBAC3DxF,QAAQC,IAAI,0BAA0B,OAAA0L,EAAArN,KAAKM,oBAAL,EAAA+M,EAAoB7J,YAAYa,SAAU,GAChF3C,QAAQC,IAAI,4BAA4B,OAAA2L,EAAAtN,KAAKK,qBAAL,EAAAiN,EAAqBzF,aAAaxD,SAAU,GAEhFrE,KAAKK,eAAgB,CACvB,MAAMkN,EAAYvN,KAAKK,eAAemN,eACtC9L,QAAQC,IAAI,6BAA8B4L,EAAUlJ,QACpDkJ,EAAU9J,QAAQ,CAACgK,EAAUC,KAC3BhM,QAAQC,IAAI,YAAY+L,KAAU,CAChChK,MAAO+J,EAAS/J,MAAQ,CACtBM,KAAMyJ,EAAS/J,MAAMM,KACrBkH,GAAIuC,EAAS/J,MAAMwH,GACnBnC,QAAS0E,EAAS/J,MAAMqF,QACxBoE,WAAYM,EAAS/J,MAAMyJ,YACzB,QAGV,CAEA,GAAI,OAAAQ,EAAA3N,KAAKQ,yBAAL,EAAAmN,EAAyB1I,UAAW,CACtC,MAAML,EAAS5E,KAAKQ,mBAAmByE,UACvCvD,QAAQC,IAAI,wBAAyB,CACnCuJ,GAAItG,EAAOsG,GACX0C,OAAQhJ,EAAOgJ,OACfC,OAAQjJ,EAAOpB,YAAYS,IAAI6J,IAAA,CAC7B9J,KAAM8J,EAAE9J,KACRkH,GAAI4C,EAAE5C,GACNnC,QAAS+E,EAAE/E,QACXoE,WAAYW,EAAEX,eAGpB,CAEAzL,QAAQqM,UACV,EAIGC,eAAeC,IAAI,yBACtBD,eAAeE,OAAO,uBAAwBtO,GAMhDuO,OAAOvO,mBAAqBA"}